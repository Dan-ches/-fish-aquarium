<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Наруто Монополия (Новый макет)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <!-- Подключение игровых модулей -->
    <script src="techniques.js"></script>
    <script src="missions.js"></script>
    <script src="modifiers.js"></script>
    <script src="duels.js"></script>
    <script src="board.js"></script>
    <style>
        /*
          === UI FIX: pointer-events для правой панели ===
          Этот блок делает .right-panel и её контейнеры прозрачными для кликов (pointer-events: none),
          а все реально интерактивные элементы внутри (кнопки, .dice-button, .player-stats-list, .player-mini и их потомки)
          снова кликабельны (pointer-events: auto).
          Это полностью убирает невидимое перекрытие клеток поля, но не ломает работу UI.
          Если снова появится баг с перекрытием клеток — ищи этот блок!
        */
        .dice-button, .player-stats-list, .player-mini, .player-mini *, .controls button, .dice-area > * {
            pointer-events: auto;
        }
        /* --- END UI FIX --- */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: #23243a;
            color: white;
            overflow-x: hidden;
        }
        /* Остальные стили из index.html без фоновых картинок и сложных анимаций */
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }
        h1 {
            margin-bottom: 10px !important;
        }
        .main-flex {
            position: relative;
            min-height: 700px;
            height: auto;
            width: 100%;
        }
        .center-panel {
            position: absolute;
            right: 364px;
            top: 0;
            margin: 0;
        }
        .dice-button {
            background: #4caf50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 20px;
            box-shadow: none;
            transition: background 0.2s;
            width: 100%;
        }
        .dice-button:hover {
            background: #388e3c;
        }
        .board-flex-fix {
            display: flex;
            justify-content: flex-end;
            width: 100%;
        }
        .board {
            width: unset;
            min-width: unset;
            max-width: unset;
        }
        .right-panel {
            position: absolute;
            right: 0;
            top: 0;
            width: 220px !important;
            min-width: 220px !important;
            max-width: 240px !important;
            font-size: 0.98em;
            padding: 0 8px 0 4px;
            margin-right: 10px;
        }
        .right-top-block {
            background: none;
            border-radius: 18px 18px 10px 10px;
            padding: 0 10px 15px 10px;
            margin-bottom: 18px;
            backdrop-filter: none;
        }
        .right-bottom-block {
            width: 190px;
            min-width: 120px;
            max-width: 100%;
            padding: 8px 2px 8px 2px;
            background: rgba(35,36,58,0.75);
            border-radius: 10px 10px 18px 18px;
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(8px);
        }
        .personal-info {
            background: linear-gradient(135deg, #ffd700, #fffbe0);
            color: #222;
            border-radius: 12px;
            padding: 18px 20px 10px 20px;
            margin-bottom: 10px;
            box-shadow: 0 0 10px rgba(255,215,0,0.2);
            font-size: 1.1em;
            font-weight: bold;
            position: relative;
        }
        .personal-info .player-icon {
            font-size: 2em;
            margin-right: 10px;
            vertical-align: middle;
        }
        .player-stats-list {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            border: none;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(120,120,120,0.18) transparent;
            margin-top: 1px;
        }
        .player-stats-list::-webkit-scrollbar {
            width: 12px;
            background: transparent;
            border-radius: 10px;
        }
        .player-stats-list::-webkit-scrollbar-thumb {
            background: rgba(120,120,120,0.18);
            border-radius: 10px 10px 10px 10px;
            border: 3px solid transparent;
            background-clip: padding-box;
            transition: background 0.3s;
        }
        .player-stats-list::-webkit-scrollbar-thumb:hover {
            background: rgba(120,120,120,0.38);
        }
        .player-stats-list::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 10px;
        }
        .player-stats-list::-webkit-scrollbar-button {
            display: none;
        }
        .player-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 6px 7px 6px;
            min-width: unset;
            font-size: 0.98em;
            word-break: break-word;
        }
        .player-stats-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            margin-bottom: 2px;
            width: 100%;
        }
        .player-stats .player-icon {
            font-size: 1.5em;
            margin-bottom: 2px;
            display: block;
        }
        .player-stats-info {
            margin-top: 2px;
            margin-left: 0;
            text-align: center;
            width: 100%;
            font-size: 0.97em;
        }
        .player-stats h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .character-choice-btn {
            border: 3px solid transparent;
            transition: border 0.2s, box-shadow 0.2s;
            position: relative;
            outline: none;
        }
        .character-choice-btn.selected {
            border: 3px solid #00e676;
            box-shadow: 0 0 15px #00e67699;
            animation: none;
        }
        .character-choice-btn.selected::after {
            content: '✔';
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 1.5em;
            color: #00e676;
            font-weight: bold;
        }
        .cell {
            width: 80px;
            height: 80px;
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-align: center;
            overflow: hidden;
            z-index: 1;
        }
        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        .cell.active {
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        .cell-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        .cell-name {
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        .cell-effect {
            font-size: 8px;
            opacity: 0.8;
        }
        .player-token {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #000;
            transition: all 0.5s ease;
            z-index: 2;
        }
        .player-0 { background: #ffd700; }
        .player-1 { background: #ff4444; }
        .player-2 { background: #ff69b4; }
        .player-3 { background: #808080; }
        .ui-panel {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        .game-info {
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .dice-cube {
            width: 44px;
            height: 44px;
            background: #fff;
            border: 2px solid #222;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            box-shadow: 0 2px 8px #0003;
            font-size: 2em;
            transition: transform 0.3s;
            padding: 0;
        }
        .dice-cube svg {
            width: 40px;
            height: 40px;
            display: block;
        }
        .dice-cube.rolling {
            animation: none;
        }
        .dice-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: none;
            z-index: 2000;
        }
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2aee;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            min-width: 300px;
            z-index: 2100;
        }
        .modal-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        .modal-button:hover {
            transform: none;
        }
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            z-index: 1001;
        }
        .tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 200px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .clan-uchiha { background: #cc0000; }
        .clan-senju { background: #00cc00; }
        .clan-hyuga { background: #0000cc; }
        .clan-aburame { background: #cc00cc; }
        .type-start { background: #cccc00; color: #000; }
        .type-technique { background: #cc6600; }
        .type-mission { background: #00cccc; color: #000; }
        .type-event { background: #cc0066; }
        .type-bonus { background: #cc6600; }
        .type-admin { background: #444444; }
        .type-utility { background: #cccccc; color: #000; }
        .type-jail { background: #000000; }
        .type-parking { background: #666666; color: #000; }
        .empty-cell {
            background: transparent;
            border: none;
            pointer-events: none;
        }
        .player-figure {
            position: absolute;
            width: 32px;
            height: 32px;
            font-size: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            transition: left 0.5s cubic-bezier(.4,2,.6,1), top 0.5s cubic-bezier(.4,2,.6,1);
            filter: drop-shadow(0 2px 4px #0008);
        }
        .cell .owner-indicator { display: none !important; }
        .header-flex {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        #board-form {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0 !important;
        }
        #board-form label {
            color: #fff;
            font-size: 1.1em;
        }
        #board-form input {
            width: 50px;
            padding: 3px 6px;
            border-radius: 5px;
            border: 1px solid #aaa;
            font-size: 1em;
        }
        #board-form button {
            padding: 5px 14px;
            border-radius: 6px;
            border: none;
            background: #4CAF50;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
        }
        .board-logo-center {
            position: absolute;
            left: 0;
            top: 80px;
            right: 0;
            bottom: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }
        .board-logo-center img {
            width: calc(100% - 160px);
            max-width: 100%;
            aspect-ratio: 1/1;
            object-fit: cover;
            object-position: center;
            opacity: 0.92;
            border-radius: 18px;
            box-shadow: none;
            overflow: hidden;
            -webkit-mask-image: none;
            mask-image: none;
        }
        .player-stats.current-player {
            border: none;
            box-shadow: none;
            background: rgba(255,255,255,0.08);
            color: #fff;
        }
        .player-stats.selected-player {
            border: 2px solid #ffd700;
            box-shadow: 0 0 10px #ffd70099;
            background: #fffbe0;
            color: #222;
        }
        #dice3d-container1, #dice3d-container2 {
            width: 140px;
            height: 140px;
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: none;
            border-radius: 0;
            border: none;
            box-shadow: none;
            margin: 0 !important;
            padding: 0 !important;
        }
        #dice3d-container1 canvas, #dice3d-container2 canvas {
            width: 140px !important;
            height: 140px !important;
            max-width: 100%;
            max-height: 100%;
        }
        .dice3d-rolling {
            /* animation: none; */
        }
        #dice3d-container2 {
            margin-left: -48px !important;
        }
        :root {
            --cell-size: 80px;
        }
        .board {
            grid-template-columns: repeat(var(--board-width, 10), var(--cell-size));
            grid-template-rows: repeat(var(--board-height, 8), var(--cell-size));
        }
        @media (max-width: 800px), (max-height: 600px) {
            :root {
                --cell-size: 44px;
            }
            .game-container, .main-flex {
                width: 100vw;
                max-width: 100vw;
                min-width: 0;
                padding: 0;
                overflow-x: auto !important;
            }
            .main-flex {
                flex-direction: column !important;
                align-items: stretch !important;
                position: static !important;
                min-height: unset !important;
                height: auto !important;
            }
            .center-panel {
                position: static !important;
                min-width: 0 !important;
                margin: 0 !important;
                width: 100% !important;
            }
            .board-flex-fix {
                justify-content: flex-start !important;
            }
            .board {
                min-width: 0 !important;
                min-height: 0 !important;
                width: 100% !important;
                max-width: 100vw !important;
                overflow-x: auto !important;
            }
            .right-panel {
                position: static !important;
                width: 140px !important;
                min-width: 120px !important;
                max-width: 160px !important;
                font-size: 0.98em;
                padding: 0 8px 0 4px;
                margin-left: 0 !important;
                margin-top: 12px !important;
            }
            .right-bottom-block, .right-top-block {
                padding: 6px 2px 6px 2px;
                width: 100% !important;
                min-width: 0 !important;
                max-width: 100vw !important;
            }
            .dice-area, .controls {
                gap: 2px;
                margin: 0;
                padding: 0;
            }
            .dice-button {
                font-size: 0.95em;
                padding: 6px 8px;
            }
            .player-stats-list {
                font-size: 0.95em;
            }
            .board-logo-center img {
                width: 80%;
                min-width: 80px;
            }
        }
        @media (max-width: 500px) {
            :root {
                --cell-size: 36px;
            }
            .right-panel {
                width: 120px !important;
                min-width: 80px !important;
                max-width: 100vw !important;
                font-size: 0.85em;
            }
            .board-logo-center img {
                width: 60%;
                min-width: 60px;
            }
        }
        /* Модалка игрока */
        #player-modal-bg {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30,32,40,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        #player-modal-bg.active { display: flex; }
        #player-modal {
            background: #23243a;
            color: #fff;
            border-radius: 14px;
            box-shadow: 0 4px 24px #0008;
            padding: 32px 28px;
            min-width: 260px;
            max-width: 90vw;
            position: relative;
        }
        #player-modal .close {
            position: absolute;
            top: 10px; right: 18px;
            font-size: 1.5rem;
            color: #fff;
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.15s;
        }
        #player-modal .close:hover { opacity: 1; }
        #player-stats-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .player-mini {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: rgba(255,255,255,0.13);
            border-radius: 10px;
            padding: 5px 2px;
            cursor: pointer;
            transition: background 0.18s, box-shadow 0.18s, border 0.18s;
            min-height: 40px;
            font-size: 1em;
            position: relative;
            margin-bottom: 4px;
            max-height: none !important;
            overflow: visible !important;
            border: 2px solid transparent;
        }
        .player-mini .player-icon {
            font-size: 1.5em;
            margin-right: 2px;
            flex-shrink: 0;
        }
        .player-mini .player-name {
            font-weight: bold;
            white-space: nowrap;
            overflow: visible;
            text-overflow: ellipsis;
            color: #fff;
            font-size: 1em;
        }
        .player-mini.active {
            background: rgba(255,255,255,0.22);
            max-height: none !important;
            box-shadow: 0 4px 18px #0003;
            border: 2px solid #ffd700;
            z-index: 2;
        }
        .player-details {
            width: 100%;
            word-break: break-word;
            box-sizing: border-box;
            overflow: visible !important;
        }
        .player-details > div {
            display: block !important;
        }
        .player-mini:not(.active) .player-details {
            opacity: 0;
            max-height: 0;
            padding: 0;
            margin: 0;
            pointer-events: none;
        }
        @keyframes fadeIn {
            from { opacity: 0; } to { opacity: 1; }
        }
        .player-main-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 2px;
        }
        .player-details {
          box-sizing: border-box !important;
          max-height: none !important;
        }
        .player-mini,
        .player-mini.active {
          min-height: 0 !important;
          box-sizing: border-box !important;
        }
        .player-mini.active {
          max-height: none !important;
        }
        .end-turn-button {
            background: #ff6b6b;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            padding: 15px 30px;
            font-size: 18px;
            margin-left: 12px;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.2s;
            display: inline-block;
        }
        .end-turn-button:hover {
            background: #ff6333;
        }
        .deck-block {
          background: linear-gradient(135deg, rgba(40,40,60,0.95), rgba(60,60,80,0.95));
          border-radius: 16px;
          box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,215,0,0.8);
          border: 2px solid #ffd700;
          transition: all 0.3s ease;
          z-index: 900 !important;
          pointer-events: auto !important;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          backdrop-filter: blur(8px);
          position: relative;
          overflow: hidden;
        }
        .deck-block::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(45deg, transparent 30%, rgba(255,215,0,0.1) 50%, transparent 70%);
          pointer-events: none;
        }
        .deck-block:hover {
          box-shadow: 0 8px 32px rgba(255,215,0,0.4), 0 0 0 3px rgba(255,215,0,0.9);
          transform: translateY(-2px);
        }
        .deck-stack {
          position: relative;
          width: 60px;
          height: 80px;
          margin-bottom: 12px;
          z-index: 2;
        }
        .deck-card.back {
          position: absolute;
          width: 60px;
          height: 80px;
          background: linear-gradient(135deg, #ffd700 0%, #fffbe0 50%, #ffd700 100%);
          border-radius: 10px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.8);
          border: 2px solid #fffbe0;
          left: 0; top: 0;
          z-index: 1;
          opacity: 1;
          display: block;
          transition: transform 0.2s ease;
        }
        .deck-card.back:nth-child(2) { 
          top: 4px; 
          left: 4px; 
          z-index: 2;
          transform: rotate(2deg);
        }
        .deck-card.back:nth-child(3) { 
          top: 8px; 
          left: 8px; 
          z-index: 3;
          transform: rotate(-1deg);
        }
        .deck-label {
          color: #ffd700;
          font-weight: bold;
          font-size: 1.1em;
          text-shadow: 0 2px 4px rgba(0,0,0,0.8);
          letter-spacing: 1px;
          z-index: 2;
          position: relative;
          text-align: center;
        }
        .deck-count {
          position: absolute;
          top: 8px;
          right: 8px;
          background: rgba(255,255,255,0.9);
          color: #23243a;
          font-weight: bold;
          font-size: 0.9em;
          padding: 2px 6px;
          border-radius: 10px;
          min-width: 20px;
          text-align: center;
          box-shadow: 0 1px 4px rgba(0,0,0,0.3);
          z-index: 4;
        }
        /* Вторая колода (миссии) */
        .deck-block.missions {
          background: linear-gradient(135deg, rgba(40,40,60,0.95), rgba(60,60,80,0.95));
          border: 2px solid #4fc3f7;
          box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 2px rgba(79,195,247,0.8);
        }
        .deck-block.missions::before {
          background: linear-gradient(45deg, transparent 30%, rgba(79,195,247,0.1) 50%, transparent 70%);
        }
        .deck-block.missions:hover {
          box-shadow: 0 8px 32px rgba(79,195,247,0.4), 0 0 0 3px rgba(79,195,247,0.9);
        }
        .deck-block.missions .deck-card.back {
          background: linear-gradient(135deg, #4fc3f7 0%, #e1f5fe 50%, #4fc3f7 100%);
          border: 2px solid #e1f5fe;
          box-shadow: 0 2px 8px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.8);
        }
        .deck-block.missions .deck-label {
          color: #4fc3f7;
        }
        .trade-tab-btn.active {
          background: #ffd700 !important;
          color: #23243a !important;
          font-weight: bold;
          box-shadow: 0 2px 8px #ffd70044;
        }
        #player-panel-body .player-tabs-bar {
          background: none;
          border: none;
          padding: 0;
          display: flex;
          flex-wrap: wrap;
          width: 100%;
          box-sizing: border-box;
        }
        #player-panel-body .player-tab-btn {
          background: #23243a;
          color: #fff;
          border: none;
          padding: 6px 8px;
          font-size: 0.98em;
          cursor: pointer;
          transition: background 0.15s, color 0.15s;
          flex: 1 1 0;
          min-width: 0;
          max-width: 100%;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        #player-panel-body .player-tab-btn.active {
          background: #ffd700;
          color: #23243a;
          font-weight: bold;
        }
        #player-panel-body .player-tab-content {
          padding: 0 2px 6px 2px;
          min-height: 40px;
        }
        @media (max-width: 500px) {
          #player-panel-body .player-tab-btn {
            padding: 4px 4px;
            font-size: 0.92em;
          }
        }
        #help-window {
          position: absolute !important;
          left: 12px !important;
          top: 80px !important;
          width: 400px !important;
          min-width: 220px;
          min-height: 180px;
          z-index: 2001;
          background: #292a3d;
          border-radius: 14px;
          box-shadow: 0 4px 24px #0008;
          padding: 22px 24px 18px 24px;
          color: #fff;
          display: none;
          /* Убираем любые трансформации и drag */
          transform: none !important;
          cursor: default !important;
          user-select: auto;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header-flex">
            <div id="game-title-block" style="position:absolute; left:40px; top:20px; min-width:120px; min-height:40px; z-index:3000; background:none; cursor:move;">
                <h1 style="margin:0;">🥷 Наруто Монополия 🥷</h1>
            </div>
            <div id="board-form-block" style="position:absolute; left:40px; top:80px; min-width:220px; min-height:40px; z-index:3000; background:none; cursor:move;">
                <form id="board-form" style="margin:0;">
                    <label>Ширина: <input type="number" id="board-width" value="10" min="3" max="20"></label>
                    <label>Высота: <input type="number" id="board-height" value="8" min="3" max="20"></label>
                    <button type="button" onclick="updateBoardSizeAndRestart()">Построить поле</button>
                </form>
            </div>
            <div id="menu-block" style="position:absolute; left:320px; top:20px; z-index:3000; display:flex; gap:10px; align-items:stretch; cursor:move; background:none; border-radius:0; box-shadow:none; padding:0; overflow:visible;">
                <button id="help-btn" type="button" style="flex:1 1 0; min-width:0; height:100%; font-size:1em; padding:0.2em 0.7em; border-radius:8px; border:2px solid #e0e0e0; background:#fff; color:#b71c1c; font-weight:500; display:flex; align-items:center; justify-content:center; gap:8px; outline:none; box-shadow:0 2px 8px #0001;">❓ Справка</button>
                <button id="stats-btn" type="button" style="flex:1 1 0; min-width:0; height:100%; font-size:1em; padding:0.2em 0.7em; border-radius:8px; border:2px solid #e0e0e0; background:#fff; color:#23243a; font-weight:500; display:flex; align-items:center; justify-content:center; gap:8px; outline:none; box-shadow:0 2px 8px #0001;">📊 Статистика</button>
                <button id="trade-btn" type="button" style="flex:1 1 0; min-width:0; height:100%; font-size:1em; padding:0.2em 0.7em; border-radius:8px; border:2px solid #e0e0e0; background:#fff; color:#23243a; font-weight:500; display:flex; align-items:center; justify-content:center; gap:8px; outline:none; box-shadow:0 2px 8px #0001;">💰 Торговля</button>
            </div>
            <div id="layout-actions" style="position:absolute; left:600px; top:28px; z-index:3000; display:flex; gap:10px; background:none; border-radius:0; box-shadow:none; padding:0; cursor:move; overflow:visible; align-items:stretch;">
                <button id="save-layout-btn" type="button" style="flex:1 1 0; min-width:0; height:100%; font-size:1em; padding:0.2em 0.7em; border-radius:8px; border:2px solid #e0e0e0; background:#fff; color:#23243a; font-weight:500; outline:none; box-shadow:0 2px 8px #0001;">Сохранить макет</button>
                <input id="load-layout-input" type="file" accept="application/json" style="display:none;">
                <button id="load-layout-btn" type="button" style="flex:1 1 0; min-width:0; height:100%; font-size:1em; padding:0.2em 0.7em; border-radius:8px; border:2px solid #e0e0e0; background:#fff; color:#23243a; font-weight:500; outline:none; box-shadow:0 2px 8px #0001;">Загрузить макет</button>
            </div>
        </div>
        <div class="main-flex">
            <div class="center-panel">
                <div class="board-flex-fix">
                    <div class="board" id="board"></div>
                </div>
            </div>
            <!-- Вынесенные элементы -->
            <div id="dice-block">
                <div id="dice3d-container1"></div>
                <div id="dice3d-container2"></div>
            </div>
            <button class="dice-button" id="dice-button" style="margin-top:-28px;">Бросить кубики</button>
            <div id="right-block" class="right-bottom-block">
                <div id="player-stats-list" class="player-stats-list"></div>
            </div>
        </div>
    </div>
    <div class="modal" id="buy-modal">
        <div class="modal-content">
            <h3>Покупка недвижимости</h3>
            <p id="buy-description"></p>
            <button class="modal-button" onclick="buyProperty()">Купить</button>
            <button class="modal-button" onclick="closeModal('buy-modal')">Пропустить</button>
        </div>
    </div>
    <div class="modal" id="card-modal">
        <div class="modal-content">
            <h3 id="card-title"></h3>
            <p id="card-description"></p>
            <button class="modal-button" onclick="closeModal('card-modal')">OK</button>
        </div>
    </div>
    <div class="modal" id="character-modal" style="display:none;">
        <div class="modal-content">
            <h3>Выберите своего персонажа</h3>
            <div id="character-choices" style="display:flex; gap:20px; justify-content:center; margin:20px 0;"></div>
            <button class="modal-button" id="confirm-character" disabled>Подтвердить</button>
        </div>
    </div>
    <div id="player-modal-bg">
      <div id="player-modal">
        <button class="close" onclick="closePlayerModal()">×</button>
        <div id="player-modal-content"></div>
      </div>
    </div>
    <!-- Новые окна -->
    <div id="trade-window" class="floating-window" style="position:absolute; left:40px; top:120px; width:420px; min-width:260px; min-height:220px; z-index:2001; background:#292a3d; border-radius:14px; box-shadow:0 4px 24px #0008; padding:22px 24px 18px 24px; color:#fff; display:none;">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
        <span style="font-size:1.2em; font-weight:bold;">💰 Торговля</span>
        <button onclick="hideWindow('trade-window')" style="background:none; border:none; color:#fff; font-size:1.3em; cursor:pointer;">✖</button>
      </div>
      <div id="trade-tabs" style="display:flex; gap:8px; margin-bottom:12px;">
        <button class="trade-tab-btn" data-tab="exchange" style="flex:1 1 0; padding:6px 0; border-radius:8px 8px 0 0; border:none; background:#23243a; color:#ffd700; font-weight:600; cursor:pointer;">Обмен</button>
        <button class="trade-tab-btn" data-tab="auction" style="flex:1 1 0; padding:6px 0; border-radius:8px 8px 0 0; border:none; background:#23243a; color:#ffd700; font-weight:600; cursor:pointer;">Аукцион</button>
        <button class="trade-tab-btn" data-tab="market" style="flex:1 1 0; padding:6px 0; border-radius:8px 8px 0 0; border:none; background:#23243a; color:#ffd700; font-weight:600; cursor:pointer;">Рынок</button>
      </div>
      <div id="trade-tab-content" style="min-height:180px;"></div>
    </div>
    <div id="stats-window" class="floating-window" style="position:absolute; top:80px; width:340px; min-width:220px; min-height:180px; z-index:2001; background:#292a3d; border-radius:14px; box-shadow:0 4px 24px #0008; padding:22px 24px 18px 24px; color:#fff; display:none;">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
        <span style="font-size:1.2em; font-weight:bold;">📊 Статистика игры</span>
        <button onclick="hideWindow('stats-window')" style="background:none; border:none; color:#fff; font-size:1.3em; cursor:pointer;">✖</button>
      </div>
      <div style="margin-bottom:10px;"><b>⏱️ Общая статистика</b><br>• Ход: 1<br>• Время игры: 00:05:30<br>• Всего бросков: 12</div>
      <div><b>🏆 Лидеры</b><br>• Богатейший: Наруто (2500 монет)<br>• Больше всего чакры: Саске (180)<br>• Больше всего техник: Какаши (5)</div>
    </div>
    <!-- Новое окно справки -->
    <div id="help-window" class="floating-window" style="position:absolute; left:80px; top:80px; width:400px; min-width:220px; min-height:180px; z-index:2001; background:#292a3d; border-radius:14px; box-shadow:0 4px 24px #0008; padding:22px 24px 18px 24px; color:#fff; display:none;">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
        <span style="font-size:1.2em; font-weight:bold;">❓ Справка</span>
        <button onclick="hideWindow('help-window')" style="background:none; border:none; color:#fff; font-size:1.3em; cursor:pointer;">✖</button>
      </div>
      <div style="margin-bottom:10px;"><b style='color:#e53935;'>★ Техники</b><br>• Расенган - 500 монет<br>• Теневая техника - 300 монет<br>• Техника клонирования - 400 монет</div>
      <div style="margin-bottom:10px;"><b style='color:#fbc02d;'>📜 Миссии</b><br>• Защита деревни - +200 монет<br>• Поиск артефакта - +150 монет<br>• Тренировка дзюцу - +100 монет</div>
      <div style="margin-bottom:10px;"><b style='color:#757575;'>⚔️ События</b><br>• Долина завершения - дуэль<br>• Бонус чакры - +50 чакры<br>• Штраф - -100 монет</div>
      <div style="margin-bottom:10px;"><b style='color:#039be5;'>ℹ️ Другая справочная информация</b><br>• Здесь будет описание правил, подсказки и FAQ.</div>
    </div>
    <div id="player-panel" style="position:absolute; left:20px; top:180px; width:320px; z-index:4000; background:#23243a; border-radius:16px; box-shadow:0 2px 16px #0007; padding:18px 18px 12px 18px; font-size:16px; display:flex; flex-direction:column; gap:10px; color:#fff; border:1.5px solid #35365a;">
        <div id="player-panel-header" style="display:flex; align-items:center; gap:12px; cursor:move;">
            <div id="player-avatar" style="font-size:36px; text-shadow:0 1px 4px #0008;">🥷</div>
            <div>
                <div id="player-name" style="font-weight:bold; font-size:20px; color:#fff; text-shadow:0 1px 4px #000;">Наруто</div>
                <div id="player-character" style="font-size:14px; color:#7ecbff;">Узумаки</div>
            </div>
            <button id="player-panel-toggle" style=" font-size:18px; background:none; border:none; cursor:pointer; color:#fff;">⏷</button>
        </div>
        <div id="player-panel-body">
            <div class="player-tabs-bar" style="margin-bottom:8px; display:flex;">
              <button class="player-tab-btn active" data-tab="main" style="border-radius:6px 0 0 6px;">Главная</button>
              <button class="player-tab-btn" data-tab="property">Имущество</button>
              <button class="player-tab-btn" data-tab="stats" style="border-radius:0 6px 6px 0;">Статистика</button>
            </div>
            <div class="player-tab-content" id="player-tab-main">
            <div style="display:flex; gap:18px; margin-bottom:8px;">
                <div title="Рё" style="display:flex; align-items:center; gap:4px; color:#ffd54f; font-weight:600; text-shadow:0 1px 4px #000;">
                    <span style="font-size:20px;">💰</span><span id="player-money">1500</span>
                </div>
                <div title="Чакра" style="display:flex; align-items:center; gap:4px; color:#40c4ff; font-weight:600; text-shadow:0 1px 4px #000;">
                    <span style="font-size:20px;">🔵</span><span id="player-chakra">80</span>/<span id="player-chakra-max">150</span>
                </div>
                <div title="Очки влияния (IP)" style="display:flex; align-items:center; gap:4px; color:#ff6b6b; font-weight:600; text-shadow:0 1px 4px #000;">
                    <span style="font-size:20px;">👑</span><span id="player-ip">0</span>
                </div>
            </div>
            <div style="margin-bottom:6px; font-weight:700; color:#7ecbff; display:flex; align-items:center; gap:6px;">
              Техники:
              <button id="open-tech-modal-btn" title="Показать все техники" style="background:none; border:none; cursor:pointer; font-size:1.1em;">🔎</button>
            </div>
            <div id="player-techniques" style="display:flex; flex-wrap:wrap; gap:8px 10px; min-height:36px;"></div>
            <div style="margin:8px 0 4px 0; font-weight:700; color:#ffd54f; display:flex; align-items:center; gap:6px;">
              Миссии:
              <button id="open-mission-modal-btn" title="Показать все миссии" style="background:none; border:none; cursor:pointer; font-size:1.1em;">📜</button>
            </div>
            <div id="player-missions" style="display:flex; flex-wrap:wrap; gap:8px 10px; min-height:32px;"></div>
            <div style="margin:8px 0 4px 0; font-weight:700; color:#a5d6a7;">Эффекты:</div>
            <div id="player-effects" style="display:flex; flex-wrap:wrap; gap:8px 10px; min-height:24px;"></div>
            </div>
            <div class="player-tab-content" id="player-tab-property" style="display:none;">
                <ul style="list-style:none; padding:0; margin:0; font-size:0.97em; color:#fff;">
                  <li style="margin-bottom:6px; color:#ffd700; font-weight:700;">[Недвижимость]</li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">#️⃣</span> Всего клеток: <b>7</b></li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">🏯</span> Учиха ×3, Нара ×2, Сенджу ×2</li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">👑</span> Монополии: <span style='color:#ffd700;'>Учиха</span>, <span style='color:#ffd700;'>Нара</span></li>
                  <li style="margin-bottom:6px; color:#ffd700; font-weight:700;">[Лимиты]</li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">🌀</span> Обычные техники: <b>2/3</b></li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">💠</span> Финальные техники: <b>1/4</b></li>
                  <li style="margin-bottom:8px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">📜</span> Свитки: <b>1/4</b></li>
                </ul>
            </div>
            <div class="player-tab-content" id="player-tab-stats" style="display:none;">
                <ul style="list-style:none; padding:0; margin:0; font-size:0.97em; color:#fff;">
                  <li style="margin-bottom:6px; color:#ffd700; font-weight:700;">[Прогресс]</li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">📜</span> Выполнено миссий: <b>2</b></li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">⚔️</span> Побед в дуэлях: <b>3</b></li>
                  <li style="margin-bottom:4px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">🏆</span> Побед в финалах: <b>1</b></li>
                  <li style="margin-bottom:8px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">👑</span> Кандидат в Хокаге: <span style='font-size:1.1em; color:#e53935;'>✗</span></li>
                  <li style="margin-bottom:8px; display:flex; align-items:center; gap:7px;"><span style="font-size:1.1em;">🏛️</span> Владение башней: <span id="tower-ownership-timer" style='font-size:1.1em; color:#4caf50;'>-</span></li>
                  <li style="margin-bottom:6px; color:#ffd700; font-weight:700;">[История]</li>
                  <li style="margin-bottom:2px; display:flex; align-items:center; gap:7px;">Победа в дуэли против Саске</li>
                  <li style="margin-bottom:2px; display:flex; align-items:center; gap:7px;">Куплена клетка Учиха</li>
                  <li style="margin-bottom:2px; display:flex; align-items:center; gap:7px;">Получен свиток Нара</li>
                </ul>
            </div>
        </div>
    </div>
    <!-- Самостоятельная drag/resize-кнопка Завершить ход -->
    <div id="end-turn-button" class="end-turn-button" style="position:absolute; left:1100px; top:180px; width:220px; height:70px; z-index:2000; font-size:32px; display:flex; align-items:center; justify-content:center; text-align:center; cursor:pointer;">
      Завершить ход
    </div>
    <script>
                    // Сопоставление персонаж-способность
                    const charAbilities = {
                'Наруто': {name: 'Теневое клонирование', icon: '👥', description: 'Если на кубике выпало меньше 4, может перебросить кубик. Активация перед броском.'},
                'Саске': {name: 'Атака на территорию', icon: '⚡', description: 'Может "атаковать" чужую территорию, снизив её ренту на 50% на *кол-во участников х2* ходов.'},
                'Сакура': {name: 'Целебная чакра', icon: '💚', description: 'Может отменить попадание в тюрьму или оплату ренты. Окно действия – 3 хода.'},
                'Какаши': {name: 'Копирующий ниндзя', icon: '📖', description: 'Может скопировать любую 1 способность/технику другого игрока. Окно активации – 3 хода.'},
                'Шикамару': {name: 'Теневая хватка', icon: '🌑', description: 'Раз за ход может "задержать" игрока на любой территории (кроме «отправиться в тюрьму», «старт»), заставив его задержаться на клетке на 1 доп. ход, под эффектом клетки. Если это его недвижка — второй раз платит только 50% ренты. Ловушка ставится заранее (окно действия – 1 ход каждого игрока).'},
                'Хината': {name: 'Лев-двойник', icon: '🦁', description: 'Удвоить свой бросок кубика для перемещения.'},
                'Гаара': {name: 'Песчаный гроб', icon: '⚰️', description: 'Может заставить другого игрока, наступившего на его территорию, пропустить следующий ход, если тот не заплатит дополнительно половину ренты.'},
                'Итачи': {name: 'Аматерасу', icon: '🔥', description: 'Сжигает один дом на чужой территории, снижая её ренту (уменьшая уровень), раз за игру.'},
                'Джирайя': {name: 'Призыв жаб', icon: '🐸', description: 'Заблокировать одну клетку на поле для всех, кроме себя. Время действия «кол-во игроков ×2».'},
                'Орочимару': {name: 'Проклятая печать', icon: '🔮', description: 'Может наложить «печать» на чужую территорию, заставляя владельца делиться половиной ренты с этой территории в течение «кол-во игроков ×2» ходов.'}
            };
        // =====================
        // boardCells: структура игрового поля
        // ВАЖНО: Всего 32 клетки! Если меняется макет — обновляйте и документацию (GAME_DESIGN.md)
        // =====================
        const boardCells = [
            // 1. Старт
            {type: "start", name: "Старт", effect: "Начало игры", icon: "▶️", color: "#ffe082"},
            // 2
            {type: "yamanka", name: "Яманака", clan: "yamanka", price: 90, effect: "Клан Яманака", icon: "🏯", color: "#f7c873"},
            // 3
            {type: "auction", name: "Аукцион", effect: "Разыгрывается свободная клетка", icon: "🔨", color: "#ffd700"},
            // 4
            {type: "yamanka", name: "Яманака", clan: "yamanka", price: 90, effect: "Клан Яманака", icon: "🏯", color: "#f7c873"},
            // 5
            {type: "technique", name: "Техника", effect: "Карточка техники", icon: "💥", color: "#ff7f50"},
            // 6
            {type: "nara", name: "Нара", clan: "nara", price: 180, effect: "Клан Нара", icon: "🏯", color: "#bdb76b"},
            // 7
            {type: "utility", name: "Чакровая электростанция", effect: "Платёж по броску кубика", icon: "⚡", color: "#b2dfdb"},
            // 8
            {type: "nara", name: "Нара", clan: "nara", price: 180, effect: "Клан Нара", icon: "🏯", color: "#bdb76b"},
            // 9
            {type: "nara", name: "Нара", clan: "nara", price: 180, effect: "Клан Нара", icon: "🏯", color: "#bdb76b"},
            // 10
            {type: "jail", name: "Тюрьма", effect: "Пропуск хода", icon: "⛓️", color: "#444444"},
            // 11
            {type: "admin", name: "Башня Хокаге", effect: "Бонус к старту", icon: "🏛️", color: "#888888", price: 500},
            // 12
            {type: "hyuga", name: "Хьюга", clan: "hyuga", price: 240, effect: "Клан Хьюга", icon: "🏯", color: "#4fc3f7"},
            // 13
            {type: "hyuga", name: "Хьюга", clan: "hyuga", price: 240, effect: "Клан Хьюга", icon: "🏯", color: "#4fc3f7"},
            // 14
            {type: "kurama", name: "Чакра Курамы", effect: "+100 чакры и иммунитет к дебаффам до следующего хода", icon: "🦊", color: "#ff7043"},
            // 15
            {type: "hyuga", name: "Хьюга", clan: "hyuga", price: 240, effect: "Клан Хьюга", icon: "🏯", color: "#4fc3f7"},
            // 16
            {type: "mission", name: "Миссия", effect: "Карточка миссии", icon: "📜", color: "#b3e5fc"},
            // 17
            {type: "market", name: "Рынок", effect: "Развиваемая клетка", icon: "🏪", color: "#a1887f"},
            // 18
            {type: "uzumaki", name: "Узумаки", clan: "uzumaki", price: 220, effect: "Клан Узумаки", icon: "🏯", color: "#ffb74d"},
            // 19
            {type: "uzumaki", name: "Узумаки", clan: "uzumaki", price: 220, effect: "Клан Узумаки", icon: "🏯", color: "#ffb74d"},
            // 20
            {type: "bonus", name: "Бонус", effect: "Получите бонус", icon: "💎", color: "#ffd54f"},
            // 21
            {type: "uzumaki", name: "Узумаки", clan: "uzumaki", price: 220, effect: "Клан Узумаки", icon: "🏯", color: "#ffb74d"},
            // 22
            {type: "utility", name: "Сеть сенсоров", effect: "Платёж по броску кубика", icon: "📡", color: "#b2dfdb"},
            // 23
            {type: "technique", name: "Техника", effect: "Карточка техники", icon: "💥", color: "#ff7f50"},
            // 24
            {type: "parking", name: "Бесплатная стоянка", effect: "Отдых", icon: "🅿️", color: "#90caf9"},
            // 25
            {type: "uchiha", name: "Учиха", clan: "uchiha", price: 400, effect: "Клан Учиха", icon: "🏯", color: "#e57373"},
            // 26
            {type: "gotojail", name: "Отправиться в тюрьму", effect: "Переместиться в тюрьму", icon: "🚩", color: "#bdbdbd"},
            // 27
            {type: "uchiha", name: "Учиха", clan: "uchiha", price: 400, effect: "Клан Учиха", icon: "🏯", color: "#e57373"},
            // 28
            {type: "event", name: "Долина завершения", effect: "Сражение с игроком", icon: "⚔️", color: "#ce93d8"},
            // 29
            {type: "senju", name: "Сенджу", clan: "senju", price: 260, effect: "Клан Сенджу", icon: "🏯", color: "#81c784"},
            // 30
            {type: "mission", name: "Миссия", effect: "Карточка миссии", icon: "📜", color: "#b3e5fc"},
            // 31
            {type: "senju", name: "Сенджу", clan: "senju", price: 260, effect: "Клан Сенджу", icon: "🏯", color: "#81c784"},
            // 32
            {type: "senju", name: "Сенджу", clan: "senju", price: 260, effect: "Клан Сенджу", icon: "🏯", color: "#81c784"}
        ];

        // =====================
        // МАССИВ PLAYERS: У каждого персонажа уже есть 2 уникальные техники (пассивка и ульта)
        // Эти техники всегда должны быть в начале массива techniques и выделяться особым цветом в UI.
        // Если реализуешь переключение между игроками — техники будут отображаться корректно для каждого.
        // Не добавляй дублирующие техники через другие механики!
        // =====================
        const players = [
            {
                name: "Наруто",
                color: "#ffd700",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Теневое клонирование', icon: '👥', type: 'ability', description: 'Если на кубике выпало меньше 4, может перебросить кубик. Активация перед броском.'},
                    {name: 'Яд', icon: '☠️', type: 'temporary', description: '-2 к броску противника на 3 хода (не действует в тюрьме, сбрасывается при попадании в тюрьму)'},
                    {name: 'Лечение', icon: '💚', type: 'instant', description: '+50 чакры'},
                    {name: 'Телепортация', icon: '📍', type: 'instant', description: 'Перемещение на 5 клеток'}
                ],
                pinnedTechniques: [],
                inJail: false,
                jailTurns: 0,
                missions: [
                    {name:'Победить в дуэли',icon:'⚔️'},
                    {name:'Владеть кланом',icon:'🏯'}
                ],
                effects: [
                    {name:'Усиление',icon:'💪'},
                    {name:'Яд',icon:'☠️'}
                ]
            },
            {
                name: "Саске",
                color: "#4a90e2",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Атака на территорию', icon: '⚡', type: 'ability', description: 'Может "атаковать" чужую территорию, снизив её ренту на 50% на *кол-во участников х2* ходов.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Сакура",
                color: "#ff69b4",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Целебная чакра', icon: '💚', type: 'ability', description: 'Может отменить попадание в тюрьму или оплату ренты. Окно действия – 3 хода.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Какаши",
                color: "#808080",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Копирующий ниндзя', icon: '📖', type: 'ability', description: 'Может скопировать любую 1 способность/технику другого игрока. Окно активации – 3 хода с момента копирования. На это время может иметь +1 технику (скопированную).'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Шикамару",
                color: "#607d8b",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Теневая хватка', icon: '🌑', type: 'ability', description: 'Раз за ход может "задержать" игрока на любой территории (кроме «отправиться в тюрьму», «старт»), заставив его задержаться на клетке на 1 доп. ход, под эффектом клетки. Если это его недвижка — второй раз платит только 50% ренты. Ловушка ставится заранее (окно действия – 1 ход каждого игрока).'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Хината",
                color: "#b3e5fc",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Лев-двойник', icon: '🦁', type: 'ability', description: 'Удвоить свой бросок кубика для перемещения.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Гаара",
                color: "#b71c1c",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Песчаный гроб', icon: '⚰️', type: 'ability', description: 'Может заставить другого игрока, наступившего на его территорию, пропустить следующий ход, если тот не заплатит дополнительно половину ренты.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Итачи",
                color: "#8b0000",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Аматерасу', icon: '🔥', type: 'ability', description: 'Сжигает один дом на чужой территории, снижая её ренту (уменьшая уровень), раз за игру.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Джирайя",
                color: "#fbc02d",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Призыв жаб', icon: '🐸', type: 'ability', description: 'Заблокировать одну клетку на поле для всех, кроме себя. Время действия «кол-во игроков ×2».'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            },
            {
                name: "Орочимару",
                color: "#a259e6",
                position: 0,
                money: 1500,
                chakra: 100,
                chakraMax: 150,
                influencePoints: 0, // IP (очки влияния)
                properties: [],
                techniques: [
                    {name: 'Проклятая печать', icon: '🔮', type: 'ability', description: 'Может наложить «печать» на чужую территорию, заставляя владельца делиться половиной ренты с этой территории в течение «кол-во игроков ×2» ходов.'}
                ],
                inJail: false,
                jailTurns: 0,
                missions: [],
                effects: []
            }
        ];

        let currentPlayer = 0;
        let gameState = "rolling";
        let diceValue1 = 0;
        let diceValue2 = 0;
        let currentCell = null;
        let cellElements = [];
        let cellCoords = [];

        let boardWidth = parseInt(document.getElementById('board-width')?.value || 10);
        let boardHeight = parseInt(document.getElementById('board-height')?.value || 8);

        let diceRolling = false;
        let doubleCount = 0; // Счётчик дублей подряд
        
        // Переменные для отслеживания владения башней Хокаге
        let hokageTowerOwner = null; // Текущий владелец башни
        let hokageTowerOwnershipTurns = {}; // Счётчик ходов владения для каждого игрока
        let hokageCandidates = []; // Список кандидатов в Хокаге

        function updateBoardSizeAndRestart() {
            boardWidth = parseInt(document.getElementById('board-width').value);
            boardHeight = parseInt(document.getElementById('board-height').value);
            initGame();
        }
        window.buildBoard = updateBoardSizeAndRestart;

        function initGame() {
            createBoard();
            createPlayerTokens();
            updateDisplay();
            setupEventListeners();
        }

        function createBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            cellElements = [];
            cellCoords = [];
            board.style.display = 'grid';
            board.style.gridTemplateColumns = `repeat(${boardWidth}, 80px)`;
            board.style.gridTemplateRows = `repeat(${boardHeight}, 80px)`;
            let cellCount = 0;
            console.log(`Создание поля ${boardWidth}x${boardHeight}, всего клеток в boardCells: ${boardCells.length}`);
            
            for (let row = 0; row < boardHeight; row++) {
                for (let col = 0; col < boardWidth; col++) {
                    let isPerimeter = false;
                    let cellIndex = -1;
                    if (row === 0) {
                        isPerimeter = true;
                        cellIndex = col;
                    }
                    else if (col === boardWidth - 1 && row > 0 && row < boardHeight - 1) {
                        isPerimeter = true;
                        cellIndex = boardWidth - 1 + row;
                    }
                    else if (row === boardHeight - 1) {
                        isPerimeter = true;
                        cellIndex = (boardWidth - 1) + (boardHeight - 1) + (boardWidth - 1 - col);
                    }
                    else if (col === 0 && row > 0 && row < boardHeight - 1) {
                        isPerimeter = true;
                        cellIndex = (boardWidth - 1) + (boardHeight - 1) + (boardWidth - 1) + (boardHeight - 1 - row);
                    }
                    
                    if (isPerimeter) {
                        console.log(`Клетка [${row},${col}] -> индекс ${cellIndex}, название: ${cellIndex >= 0 && cellIndex < boardCells.length ? boardCells[cellIndex].name : 'ВНЕ ДИАПАЗОНА'}`);
                    }
                    
                    if (isPerimeter && cellIndex >= 0 && cellIndex < boardCells.length) {
                        const cell = document.createElement('div');
                        cell.className = `cell type-${boardCells[cellIndex].type}`;
                        if (boardCells[cellIndex].clan) {
                            cell.classList.add(`clan-${boardCells[cellIndex].clan}`);
                        }
                        cell.innerHTML = `
                            <div class="cell-icon">${boardCells[cellIndex].icon}</div>
                            <div class="cell-name">${boardCells[cellIndex].name}</div>
                            <div class="cell-effect">${boardCells[cellIndex].effect}</div>
                        `;
                        if (boardCells[cellIndex].color) {
                            cell.style.backgroundColor = boardCells[cellIndex].color;
                        }
                        cell.addEventListener('click', () => showCellInfo(cellIndex));
                        cell.addEventListener('mouseenter', (e) => showTooltip(e, cellIndex));
                        cell.addEventListener('mouseleave', hideTooltip);
                        cell.style.gridColumn = (col + 1);
                        cell.style.gridRow = (row + 1);
                        board.appendChild(cell);
                        cellElements[cellIndex] = cell;
                        cellCoords[cellIndex] = {col, row};
                        cellCount++;
                    } else {
                        const empty = document.createElement('div');
                        empty.className = 'empty-cell';
                        empty.style.gridColumn = (col + 1);
                        empty.style.gridRow = (row + 1);
                        board.appendChild(empty);
                    }
                }
            }
            console.log(`Создано клеток периметра: ${cellCount}`);
            setTimeout(fitRightBlockToBoard, 0);
        }

        function createPlayerTokens() {
            document.querySelectorAll('.player-figure').forEach(e => e.remove());
            const cellPlayers = {};
            players.forEach((player, idx) => {
                const pos = player.position || 0;
                if (!cellPlayers[pos]) cellPlayers[pos] = [];
                cellPlayers[pos].push(idx);
            });
            players.forEach((player, index) => {
                const token = document.createElement('div');
                token.className = 'player-figure';
                token.id = `player-${index}`;
                token.innerHTML = player.img || '🙂';
                const pos = player.position || 0;
                const playersHere = cellPlayers[pos];
                let offset = {x: 24, y: 24};
                if (playersHere.length > 1) {
                    const idxInCell = playersHere.indexOf(index);
                    const offsets = [
                        {x: 8, y: 8},
                        {x: 40, y: 8},
                        {x: 8, y: 40},
                        {x: 40, y: 40},
                        {x: 24, y: 8},
                        {x: 24, y: 40}
                    ];
                    offset = offsets[idxInCell] || {x: 24, y: 24};
                }
                placeToken(token, pos, offset);
                document.getElementById('board').appendChild(token);
            });
        }

        function placeToken(token, cellIndex, offset = {x:24, y:24}) {
            if (!cellCoords[cellIndex]) return;
            const {col, row} = cellCoords[cellIndex];
            token.style.left = `${col * 80 + offset.x}px`;
            token.style.top = `${row * 80 + offset.y}px`;
        }

        function setupEventListeners() {
            document.getElementById('dice-button').addEventListener('click', rollDice);
        }

        function rollDice() {
            if (gameState !== "rolling" || diceRolling) return;
            diceRolling = true;
            const button = document.getElementById('dice-button');
            button.disabled = true;
            const prevText = button.textContent;
            button.textContent = "Бросаем...";
            if (diceCube1 && diceCube2) {
                roll3DDicePair();
            } else {
                // fallback: просто случайные значения
                setTimeout(() => {
                    diceValue1 = Math.floor(Math.random() * 6) + 1;
                    diceValue2 = Math.floor(Math.random() * 6) + 1;
                    button.textContent = prevText;
                    button.disabled = false;
                    diceRolling = false;
                    movePlayer();
                }, 900);
            }
        }

        function movePlayer() {
            const player = players[currentPlayer];
            const oldPosition = player.position;
            const diceSum = diceValue1 + diceValue2;
            // Проверка на дубль
            if (diceValue1 === diceValue2) {
                doubleCount++;
                if (doubleCount === 3) {
                    // 3 дубля подряд — отправляем в тюрьму
                    doubleCount = 0;
                    sendToJail(player);
                    return;
                }
            } else {
                doubleCount = 0;
            }
            const newPosition = (oldPosition + diceSum) % boardCells.length;
            player.position = newPosition;
            createPlayerTokens();
            animateFigureJump(currentPlayer);
            setTimeout(() => {
                highlightCell(newPosition);
                performCellAction(newPosition);
                updateDisplay();
                // nextPlayer(); // Удалено: теперь переход хода только вручную
                const button = document.getElementById('dice-button');
                button.textContent = 'Бросить кубики';
                button.disabled = true;
            }, 1000);
        }

        function sendToJail(player) {
            // Находим индекс клетки тюрьмы
            const jailIndex = boardCells.findIndex(cell => cell.type === 'jail');
            player.position = jailIndex >= 0 ? jailIndex : 0;
            player.inJail = true;
            player.jailTurns = 3;
            createPlayerTokens();
            highlightCell(player.position);
            showMessage("3 дубля подряд! Отправлен в тюрьму на 3 хода!");
            updateDisplay();
            setTimeout(nextPlayer, 1200);
        }

        function highlightCell(index) {
            cellElements.forEach(cell => cell && cell.classList.remove('active'));
            if (cellElements[index]) cellElements[index].classList.add('active');
        }

        function performCellAction(index) {
            const cell = boardCells[index];
            const player = players[currentPlayer];
            
            switch(cell.type) {
                case "start":
                    player.money += 200;
                    player.chakra += 50;
                    showMessage(`Получено 200 рё и 50 чакры!`);
                    break;
                    
                case "uchiha":
                case "senju":
                case "hyuga":
                case "aburame":
                    handlePropertyAction(cell);
                    break;
                    
                case "technique":
                    // Автоматически вытягиваем карту техники
                    setTimeout(() => {
                        drawCard('techniques');
                    }, 500);
                    break;
                    
                case "mission":
                    // Автоматически вытягиваем карту миссии
                    setTimeout(() => {
                        drawCard('missions');
                    }, 500);
                    break;
                    
                case "event":
                    handleEventAction(cell);
                    break;
                    
                case "bonus":
                    handleBonusAction(cell);
                    break;
                    
                case "admin":
                    handleAdminAction(cell);
                    break;
                    
                case "utility":
                    handleUtilityAction(cell);
                    break;
                    
                case "jail":
                    // Теперь ничего не происходит при попадании на тюрьму
                    showMessage("Просто тюрьма. Отдыхай!");
                    break;
                    
                case "gotojail":
                    sendToJail(player);
                    break;
                    
                case "parking":
                    showMessage("Бесплатная стоянка - отдых!");
                    break;
            }
        }

        function handlePropertyAction(cell) {
            const player = players[currentPlayer];
            if (cell.owner !== undefined && cell.owner !== null) {
                if (cell.owner !== currentPlayer) {
                    const rent = calculateRent(cell);
                    player.money -= rent;
                    players[cell.owner].money += rent;
                    showMessage(`Оплата аренды: ${rent} рё`);
                } else {
                    showMessage('Это ваша собственность!');
                }
            } else {
                if (player.money >= cell.price) {
                    showBuyDialog(cell);
                } else {
                    showMessage('Недостаточно денег!');
                }
            }
        }

        function showBuyDialog(cell) {
            currentCell = cell;
            document.getElementById('buy-description').textContent = 
                `Хотите купить ${cell.name} за ${cell.price} рё?`;
            document.getElementById('buy-modal').style.display = 'block';
        }

        function buyProperty() {
            const player = players[currentPlayer];
            player.money -= currentCell.price;
            currentCell.owner = currentPlayer;
            player.properties.push(currentCell);
            
            // Специальный бонус за покупку Башни Хокаге
            if (currentCell.name === "Башня Хокаге") {
                player.influencePoints += 2;
                showMessage(`Куплено: ${currentCell.name} +2 IP!`);
            } else {
                showMessage(`Куплено: ${currentCell.name}`);
            }
            
            updatePropertyOwnership(currentCell);
            closeModal('buy-modal');
        }

        function updatePropertyOwnership(cell) {
            const cellIndex = boardCells.indexOf(cell);
            const visualCell = document.querySelectorAll('.cell')[cellIndex];
            const old = visualCell.querySelector('.owner-indicator');
            if (old) old.remove();
            if (cell.owner !== undefined && cell.owner !== null) {
                const indicator = document.createElement('div');
                indicator.className = 'owner-indicator';
                indicator.style.position = 'absolute';
                indicator.style.left = '4px';
                indicator.style.top = '4px';
                indicator.style.width = '16px';
                indicator.style.height = '16px';
                indicator.style.borderRadius = '50%';
                indicator.style.background = players[cell.owner].color;
                indicator.style.border = '2px solid #fff';
                indicator.style.zIndex = 5;
                visualCell.appendChild(indicator);
            }
        }

        // Старые функции удалены - теперь используются новые карточные модалки

        function handleEventAction(cell) {
            const player = players[currentPlayer];
            
            if (cell.name === "Дуэль") {
                showDuelModal();
            } else if (cell.name === "Потеря чакры") {
                player.chakra = Math.max(0, player.chakra - 30);
                showMessage("Потеряно 30 чакры!");
            } else if (cell.name === "Случайность") {
                const effect = Math.floor(Math.random() * 151) - 50;
                player.money += effect;
                showMessage(`Случайность: ${effect} рё!`);
            } else if (cell.name === "Обмен") {
                showMessage("Возможность обмена!");
            }
        }

        function handleBonusAction(cell) {
            const player = players[currentPlayer];
            
            switch(cell.name) {
                case "Тренировка":
                    player.chakra = Math.min(200, player.chakra + 50);
                    showMessage("Получено 50 чакры!");
                    break;
                case "Лечебница":
                    player.chakra = Math.min(200, player.chakra + 100);
                    showMessage("Восстановлено здоровье!");
                    break;
            }
        }

        function handleAdminAction(cell) {
            switch(cell.name) {
                case "Башня Хокаге":
                    // Убрано сообщение о бонусе к старту
                    break;
                case "Совет старейшин":
                    showMessage("Защита от штрафов!");
                    break;
                case "Академия ниндзя":
                    showMessage("Бонус к техникам!");
                    break;
            }
        }

        function handleUtilityAction(cell) {
            showMessage("Доступ к информации о других игроках!");
        }

        function calculateRent(cell) {
            let baseRent = cell.price * 0.1;
            const owner = players[cell.owner];
            
            const clanProperties = getClanProperties(cell.clan);
            let ownsClan = true;
            for (let prop of clanProperties) {
                if (prop.owner !== cell.owner) {
                    ownsClan = false;
                    break;
                }
            }
            
            if (ownsClan) {
                baseRent *= 2;
            }
            
            return Math.floor(baseRent);
        }

        function getClanProperties(clan) {
            return boardCells.filter(cell => cell.clan === clan);
        }
        
        // Проверка лимита владения башней Хокаге
        function checkHokageTowerOwnershipLimit(player) {
            if (hokageTowerOwner === player) {
                // Увеличиваем счётчик ходов владения
                if (!hokageTowerOwnershipTurns[player.name]) {
                    hokageTowerOwnershipTurns[player.name] = 0;
                }
                hokageTowerOwnershipTurns[player.name]++;
                
                // Проверяем, является ли игрок кандидатом
                const isCandidate = hokageCandidates.includes(player);
                
                // Если не кандидат и превышен лимит (15 ходов)
                if (!isCandidate && hokageTowerOwnershipTurns[player.name] > 15) {
                    showMessage(`${player.name} превысил лимит владения башней! Башня выставляется на аукцион.`);
                    startHokageTowerAuction();
                    return;
                }
            }
        }
        
        // Запуск аукциона башни Хокаге
        function startHokageTowerAuction() {
            const auctionPrice = 350; // 30% скидка от полной стоимости 500 рё
            showMessage(`Аукцион башни Хокаге! Стартовая цена: ${auctionPrice} рё`);
            
            // Создаём аукцион
            const auction = {
                item: "Башня Хокаге",
                currentPrice: auctionPrice,
                startTime: Date.now(),
                bids: [],
                state: "waiting_first_bid",
                winner: null
            };
            
            // Таймер на первую ставку (5 секунд)
            setTimeout(() => {
                if (auction.state === "waiting_first_bid" && auction.bids.length === 0) {
                    // Никто не сделал ставку - башня становится вакантной
                    endHokageTowerAuction(null);
                }
            }, 5000);
            
            // Сохраняем аукцион в глобальной переменной
            window.currentHokageTowerAuction = auction;
        }
        
        // Завершение аукциона башни Хокаге
        function endHokageTowerAuction(winner) {
            if (winner) {
                // Победитель аукциона получает башню
                winner.money -= window.currentHokageTowerAuction.currentPrice;
                hokageTowerOwner = winner;
                hokageTowerOwnershipTurns[winner.name] = 0; // Обнуляем счётчик для нового владельца
                showMessage(`${winner.name} выиграл аукцион башни Хокаге!`);
            } else {
                // Башня становится вакантной
                hokageTowerOwner = null;
                showMessage("Башня Хокаге стала вакантной!");
            }
            
            // Обнуляем счётчик для старого владельца
            if (hokageTowerOwner !== winner) {
                const oldOwner = players.find(p => p === hokageTowerOwner);
                if (oldOwner) {
                    hokageTowerOwnershipTurns[oldOwner.name] = 0;
                }
            }
            
            window.currentHokageTowerAuction = null;
        }
        
        // Установка владельца башни (при покупке)
        function setHokageTowerOwner(player) {
            hokageTowerOwner = player;
            hokageTowerOwnershipTurns[player.name] = 0; // Обнуляем счётчик для нового владельца
        }
        
        // Добавление кандидата в Хокаге
        function addHokageCandidate(player) {
            if (!hokageCandidates.includes(player)) {
                hokageCandidates.push(player);
                showMessage(`${player.name} стал кандидатом в Хокаге!`);
            }
        }
        
        // Удаление кандидата из Хокаге
        function removeHokageCandidate(player) {
            const index = hokageCandidates.indexOf(player);
            if (index !== -1) {
                hokageCandidates.splice(index, 1);
                showMessage(`${player.name} больше не кандидат в Хокаге.`);
            }
        }
        
        // Обновление таймера владения башней в персональном окне
        function updateTowerOwnershipTimer(player) {
            const timerElement = document.getElementById('tower-ownership-timer');
            if (!timerElement) return;
            
            // Проверяем, является ли игрок владельцем башни
            if (hokageTowerOwner === player) {
                const turnsOwned = hokageTowerOwnershipTurns[player.name] || 0;
                const isCandidate = hokageCandidates.includes(player);
                
                if (isCandidate) {
                    // Кандидат в Хокаге - лимита нет
                    timerElement.textContent = 'Кандидат (без лимита)';
                    timerElement.style.color = '#4caf50'; // Зеленый
                } else {
                    // Обычный владелец - показываем оставшиеся ходы
                    const remainingTurns = 15 - turnsOwned;
                    if (remainingTurns > 0) {
                        timerElement.textContent = `${remainingTurns} ходов`;
                        if (remainingTurns <= 3) {
                            timerElement.style.color = '#ff5722'; // Красный для предупреждения
                        } else if (remainingTurns <= 7) {
                            timerElement.style.color = '#ff9800'; // Оранжевый
                        } else {
                            timerElement.style.color = '#4caf50'; // Зеленый
                        }
                    } else {
                        timerElement.textContent = 'Лимит превышен!';
                        timerElement.style.color = '#f44336'; // Красный
                    }
                }
            } else {
                // Не владелец башни
                timerElement.textContent = 'Не владеет';
                timerElement.style.color = '#9e9e9e'; // Серый
            }
        }

        function nextPlayer() {
            currentPlayer = (currentPlayer + 1) % players.length;
            
            const player = players[currentPlayer];
            if (player.chakra <= 0) {
                showMessage(`${player.name} пропускает ход из-за отсутствия чакры!`);
                setTimeout(nextPlayer, 1500);
                return;
            }
            if (player.inJail) {
                player.jailTurns -= 1;
                if (player.jailTurns <= 0) {
                    player.inJail = false;
                    showMessage(`${player.name} вышел из тюрьмы!`);
                } else {
                    showMessage(`${player.name} в тюрьме еще ${player.jailTurns} ход(ов)`);
                    setTimeout(nextPlayer, 1500);
                    return;
                }
            }
            
            // Проверка лимита владения башней Хокаге
            checkHokageTowerOwnershipLimit(player);
            
            gameState = "rolling";
            document.getElementById('dice-button').disabled = false;
            document.getElementById('dice-button').textContent = "Бросить кубики";
            updateDisplay();
        }

        // --- Глобальная переменная для раскрытия карточки игрока ---
        let openedPlayerIdx = null;
        if (typeof window.playersListCollapsed === 'undefined') window.playersListCollapsed = false;

        function createPlayerDetails(p, index) {
            const details = document.createElement('div');
            details.className = 'player-details';
            details.style.marginTop = '4px';
            details.style.marginLeft = '5px';
            details.innerHTML = `
                <div>Деньги: <b>${p.money} рё</b></div>
                <div>Чакра: <b>${p.chakra}</b></div>
                <div>IP: <b>${p.influencePoints || 0}</b></div>
                <div>Недвижимость: <b>${(boardCells.filter(cell => cell.owner === index).length) || 0}</b></div>
                <div>Техники: <b>${(p.techniques ? p.techniques.length : 0)}</b></div>
                ${p.inJail ? `<div>Тюрьма: <b>${p.jailTurns} ход(ов)</b></div>` : ''}
            `;
            return details;
        }

        function showMessage(text) {
            const message = document.createElement('div');
            message.className = 'message';
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.remove();
            }, 3000);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function showCellInfo(index) {
            const cell = boardCells[index];
            let info = `Клетка ${index + 1}: ${cell.name}\n`;
            info += `Эффект: ${cell.effect}\n`;
            if (cell.price) {
                info += `Цена: ${cell.price} рё\n`;
            }
            if (cell.owner !== undefined) {
                info += `Владелец: ${cell.owner !== null ? players[cell.owner].name : 'Нет'}`;
            }
            alert(info);
        }

        function showTooltip(e, cellIndex) {
            const cell = boardCells[cellIndex];
            let tooltip = document.getElementById('tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'tooltip';
                tooltip.style.position = 'fixed';
                tooltip.style.zIndex = 10000;
                tooltip.style.background = 'rgba(30,30,30,0.95)';
                tooltip.style.color = '#fff';
                tooltip.style.padding = '8px 14px';
                tooltip.style.borderRadius = '8px';
                tooltip.style.fontSize = '1em';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.boxShadow = '0 2px 12px #0008';
                document.body.appendChild(tooltip);
            }
            tooltip.innerHTML = `Клетка ${cellIndex + 1}: ${cell.name} ${cell.clan ? 'Клан ' + cell.name : ''}<br>Цена: ${cell.price ? cell.price + ' рё' : ''}`;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 16) + 'px';
            tooltip.style.top = (e.clientY + 8) + 'px';
        }

        function hideTooltip() {
            let tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
                tooltip.remove();
            }
        }

        window.buyProperty = buyProperty;
        window.closeModal = closeModal;

        window.addEventListener('DOMContentLoaded', () => {
            boardWidth = parseInt(document.getElementById('board-width').value);
            boardHeight = parseInt(document.getElementById('board-height').value);
            document.getElementById('board-form').onsubmit = (e) => { e.preventDefault(); updateBoardSizeAndRestart(); };
            initGame();
            showCharacterModal();
        });

        const availableCharacters = [
            {name: "Наруто", color: "#ffd700", img: "🦊"},
            {name: "Саске", color: "#4a90e2", img: "🗡️"},
            {name: "Сакура", color: "#ff69b4", img: "🌸"},
            {name: "Какаши", color: "#808080", img: "🐺"},
            {name: "Шикамару", color: "#607d8b", img: "💭"},
            {name: "Хината", color: "#b3e5fc", img: "🦋"},
            {name: "Гаара", color: "#b71c1c", img: "🏜️"},
            {name: "Итачи", color: "#8b0000", img: '<img src="picture/crow.png" style="height:1.3em;vertical-align:middle">'},
            {name: "Джирайя", color: "#fbc02d", img: "🐸"},
            {name: "Орочимару", color: "#a259e6", img: "🐍"}
        ];
        let chosenCharacter = null;

        function showCharacterModal() {
            window.isChoosingCharacter = true;
            updateDisplay(); // сразу обновляем список игроков на пустой
            const modal = document.getElementById('character-modal');
            const choices = document.getElementById('character-choices');
            choices.innerHTML = '';
            availableCharacters.forEach((char, idx) => {
                const btn = document.createElement('button');
                btn.className = 'modal-button character-choice-btn';
                btn.style.background = char.color;
                btn.innerHTML = `<div style="font-size:2em;">${char.img}</div>${char.name}`;
                btn.onclick = () => {
                    chosenCharacter = idx;
                    Array.from(choices.children).forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    document.getElementById('confirm-character').disabled = false;
                };
                choices.appendChild(btn);
            });
            document.getElementById('confirm-character').onclick = () => {
                const used = [chosenCharacter];
                const others = availableCharacters.map((c, i) => i).filter(i => !used.includes(i));
                // --- Исправление: ищем шаблон игрока по имени и копируем техники ---
                const chosenName = availableCharacters[chosenCharacter].name;
                const templatePlayer = players.find(p => p.name === chosenName);
                players[0].name = chosenName;
                players[0].color = availableCharacters[chosenCharacter].color;
                players[0].img = availableCharacters[chosenCharacter].img;
                // Копируем техники и сбрасываем закреплённые техники
                if (templatePlayer) {
                    players[0].techniques = JSON.parse(JSON.stringify(templatePlayer.techniques));
                    players[0].pinnedTechniques = [];
                }
                for (let i = 1; i < players.length; i++) {
                    const idx = others.shift();
                    const otherName = availableCharacters[idx].name;
                    const otherTemplate = players.find(p => p.name === otherName);
                    players[i].name = otherName;
                    players[i].color = availableCharacters[idx].color;
                    players[i].img = availableCharacters[idx].img;
                    if (otherTemplate) {
                        players[i].techniques = JSON.parse(JSON.stringify(otherTemplate.techniques));
                        players[i].pinnedTechniques = [];
                    }
                }
                // --- Оставляем только выбранных игроков (например, 6) ---
                players.length = 6;
                // --- Перемешиваем порядок игроков случайно ---
                for (let i = players.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [players[i], players[j]] = [players[j], players[i]];
                }
                // --- После перемешивания находим выбранного персонажа и обновляем панель именно для него ---
                const myPlayer = players.find(p => p.name === chosenName);
                // Сохраняем выбранного игрока в глобальной переменной
                window.selectedPlayer = myPlayer;
                window.selectedPlayerIndex = players.indexOf(myPlayer);
                document.getElementById('character-modal').style.display = 'none';
                window.isChoosingCharacter = false;
                updateDisplay(); // после выбора возвращаем обычный список
                createPlayerTokens();
                if (typeof renderPlayerPanel === 'function' && myPlayer) {
                    renderPlayerPanel(myPlayer);
                }
            };
            document.getElementById('confirm-character').disabled = true;
            modal.style.display = 'block';
        }

        function showDuelModal() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `<div class="modal-content"><h3>Выберите соперника для дуэли</h3><div id="duel-choices"></div><button class="modal-button" id="duel-cancel">Отмена</button></div>`;
            document.body.appendChild(modal);
            const choices = modal.querySelector('#duel-choices');
            players.forEach((p, idx) => {
                if (idx !== currentPlayer) {
                    const btn = document.createElement('button');
                    btn.className = 'modal-button';
                    btn.textContent = p.name;
                    btn.onclick = () => {
                        startDuel(idx, modal);
                    };
                    choices.appendChild(btn);
                }
            });
            modal.querySelector('#duel-cancel').onclick = () => { modal.remove(); };
        }

        function startDuel(opponentIdx, modal) {
            const player = players[currentPlayer];
            const opponent = players[opponentIdx];
            const playerRoll = Math.floor(Math.random() * 6) + 1;
            const opponentRoll = Math.floor(Math.random() * 6) + 1;
            let result = '';
            if (playerRoll > opponentRoll) {
                player.money += 50;
                player.chakra = Math.min(200, player.chakra + 10);
                opponent.money = Math.max(0, opponent.money - 30);
                opponent.chakra = Math.max(0, opponent.chakra - 10);
                result = `${player.name} выиграл дуэль! +50 рё, +10 чакры. ${opponent.name} теряет 30 рё и 10 чакры.`;
            } else if (playerRoll < opponentRoll) {
                opponent.money += 50;
                opponent.chakra = Math.min(200, opponent.chakra + 10);
                player.money = Math.max(0, player.money - 30);
                player.chakra = Math.max(0, player.chakra - 10);
                result = `${opponent.name} выиграл дуэль! +50 рё, +10 чакры. ${player.name} теряет 30 рё и 10 чакры.`;
            } else {
                result = 'Ничья! Никто ничего не теряет.';
            }
            showMessage(result + ` (Кубики: ${playerRoll} vs ${opponentRoll})`);
            modal.remove();
            updateDisplay();
            // nextPlayer(); // Удалено: теперь переход хода только вручную
        }

        function animateFigureJump(playerIndex) {
            const token = document.getElementById(`player-${playerIndex}`);
            if (!token) return;
            token.style.transition = 'none';
            token.style.transform = 'translateY(-18px) scale(1.2)';
            setTimeout(() => {
                token.style.transition = 'transform 0.35s cubic-bezier(.4,2,.6,1)';
                token.style.transform = 'translateY(0) scale(1)';
            }, 30);
        }

        function getDiceSVG(val) {
            const dots = [
                '',
                '<circle cx="28" cy="28" r="5" fill="#222"/>',
                '<circle cx="16" cy="16" r="5" fill="#222"/><circle cx="40" cy="40" r="5" fill="#222"/>',
                '<circle cx="16" cy="16" r="5" fill="#222"/><circle cx="28" cy="28" r="5" fill="#222"/><circle cx="40" cy="40" r="5" fill="#222"/>',
                '<circle cx="16" cy="16" r="5" fill="#222"/><circle cx="40" cy="16" r="5" fill="#222"/><circle cx="16" cy="40" r="5" fill="#222"/><circle cx="40" cy="40" r="5" fill="#222"/>',
                '<circle cx="16" cy="16" r="5" fill="#222"/><circle cx="40" cy="16" r="5" fill="#222"/><circle cx="28" cy="28" r="5" fill="#222"/><circle cx="16" cy="40" r="5" fill="#222"/><circle cx="40" cy="40" r="5" fill="#222"/>',
                '<circle cx="16" cy="16" r="5" fill="#222"/><circle cx="40" cy="16" r="5" fill="#222"/><circle cx="16" cy="28" r="5" fill="#222"/><circle cx="40" cy="28" r="5" fill="#222"/><circle cx="16" cy="40" r="5" fill="#222"/><circle cx="40" cy="40" r="5" fill="#222"/>'
            ];
            return `<svg viewBox="0 0 56 56"><defs><radialGradient id="g" cx="50%" cy="50%" r="60%"><stop offset="0%" stop-color="#fff"/><stop offset="100%" stop-color="#e0e0e0"/></radialGradient></defs><rect x="2" y="2" width="52" height="52" rx="12" fill="url(%23g)"/><g>${dots[val]}</g></svg>`;
        }

        // 3D Dice Implementation (две кости)
        let diceScene1, diceCamera1, diceRenderer1, diceCube1;
        let diceScene2, diceCamera2, diceRenderer2, diceCube2;
        let diceAnimationId1, diceAnimationId2;
        let currentDiceValue1 = 1, currentDiceValue2 = 1;

        function init3DDicePair() {
            create3DDice('dice3d-container1', 1);
            create3DDice('dice3d-container2', 2);
        }

        function create3DDice(containerId, diceNum) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = null;

            // Camera setup
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(0, 0, 5);

            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(140, 140); // High-res output
            renderer.setClearColor(0x000000, 0);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.7);
            pointLight.position.set(-5, -5, 5);
            scene.add(pointLight);

            // Create dice geometry
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const materials = [];
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                // Очищаем canvas
                ctx.clearRect(0, 0, 512, 512);
                // Скруглённая область
                ctx.save();
                ctx.beginPath();
                const r = 64;
                ctx.moveTo(r, 0);
                ctx.lineTo(512 - r, 0);
                ctx.quadraticCurveTo(512, 0, 512, r);
                ctx.lineTo(512, 512 - r);
                ctx.quadraticCurveTo(512, 512, 512 - r, 512);
                ctx.lineTo(r, 512);
                ctx.quadraticCurveTo(0, 512, 0, 512 - r);
                ctx.lineTo(0, r);
                ctx.quadraticCurveTo(0, 0, r, 0);
                ctx.closePath();
                ctx.clip();
                // Градиентный фон для объёма
                const grad = ctx.createRadialGradient(256, 256, 80, 256, 256, 256);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.6, '#f3f3f3');
                grad.addColorStop(1, '#d0d0d0');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 512, 512);
                ctx.restore();
                // Скруглённая граница
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(r, 0);
                ctx.lineTo(512 - r, 0);
                ctx.quadraticCurveTo(512, 0, 512, r);
                ctx.lineTo(512, 512 - r);
                ctx.quadraticCurveTo(512, 512, 512 - r, 512);
                ctx.lineTo(r, 512);
                ctx.quadraticCurveTo(0, 512, 0, 512 - r);
                ctx.lineTo(0, r);
                ctx.quadraticCurveTo(0, 0, r, 0);
                ctx.closePath();
                ctx.strokeStyle = '#111';
                ctx.lineWidth = 16;
                ctx.stroke();
                ctx.restore();
                // Тени точек
                ctx.shadowColor = 'rgba(0,0,0,0.38)';
                ctx.shadowBlur = 18;
                // Точки
                ctx.fillStyle = '#000';
                const dots = getDiceDots(i + 1, 512);
                dots.forEach(dot => {
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, 62, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.needsUpdate = true;
                const material = new THREE.MeshPhongMaterial({ map: texture, shininess: 120 });
                materials.push(material);
            }
            const cube = new THREE.Mesh(geometry, materials);
            scene.add(cube);

            // Store references
            if (diceNum === 1) {
                diceScene1 = scene; diceCamera1 = camera; diceRenderer1 = renderer; diceCube1 = cube;
                animateDice1();
            } else {
                diceScene2 = scene; diceCamera2 = camera; diceRenderer2 = renderer; diceCube2 = cube;
                animateDice2();
            }
        }

        function animateDice1() {
            diceAnimationId1 = requestAnimationFrame(animateDice1);
            diceRenderer1.render(diceScene1, diceCamera1);
        }
        function animateDice2() {
            diceAnimationId2 = requestAnimationFrame(animateDice2);
            diceRenderer2.render(diceScene2, diceCamera2);
        }

        function roll3DDicePair() {
            if (!diceCube1 || !diceCube2) return;
            const button = document.getElementById('dice-button');
            const prevText = button.textContent;
            button.textContent = "Бросаем...";
            button.disabled = true;

            // Генерируем значения один раз для всего
            const value1 = Math.floor(Math.random() * 6) + 1;
            const value2 = Math.floor(Math.random() * 6) + 1;
            diceValue1 = value1;
            diceValue2 = value2;

            // Таблица вращений для каждой грани
            const rotations = [
                { x: 0, y: -Math.PI/2, z: 0 },    // 1
                { x: 0, y: Math.PI/2, z: 0 },     // 2 (теперь как было у 4)
                { x: Math.PI/2, y: 0, z: 0 },     // 3 (теперь как было у 2)
                { x: -Math.PI/2, y: 0, z: 0 },    // 4 (теперь как было у 3)
                { x: 0, y: 0, z: 0 },             // 5
                { x: Math.PI, y: 0, z: 0 }        // 6
            ];
            const targetRotation1 = rotations[value1 - 1];
            const targetRotation2 = rotations[value2 - 1];
            diceCube1.rotation.set(0, 0, 0);
            diceCube2.rotation.set(0, 0, 0);
            const duration = 1200;
            const startTime = Date.now();
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                const spins = 4;
                // Крутим кубики, но в конце они встают на нужную грань
                const currentRotation1 = {
                    x: targetRotation1.x + spins * Math.PI * 2 * (1 - easeOut),
                    y: targetRotation1.y + spins * Math.PI * 2 * (1 - easeOut),
                    z: targetRotation1.z + spins * Math.PI * 2 * (1 - easeOut)
                };
                const currentRotation2 = {
                    x: targetRotation2.x + spins * Math.PI * 2 * (1 - easeOut),
                    y: targetRotation2.y + spins * Math.PI * 2 * (1 - easeOut),
                    z: targetRotation2.z + spins * Math.PI * 2 * (1 - easeOut)
                };
                diceCube1.rotation.set(currentRotation1.x, currentRotation1.y, currentRotation1.z);
                diceCube2.rotation.set(currentRotation2.x, currentRotation2.y, currentRotation2.z);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // В конце гарантируем нужную грань
                    diceCube1.rotation.set(targetRotation1.x, targetRotation1.y, targetRotation1.z);
                    diceCube2.rotation.set(targetRotation2.x, targetRotation2.y, targetRotation2.z);
                    button.textContent = prevText;
                    button.disabled = false;
                    diceRolling = false;
                    movePlayer();
                }
            }
            animate();
        }

        // Функция для определения верхней грани по rotation
        function getTopFaceFromRotation(rotation) {
            // Упрощённая логика для стандартного кубика:
            // x=0,y=0,z=0 -> 1 (верх)
            // x=0,y=PI/2 -> 2
            // x=-PI/2 -> 3
            // x=PI/2 -> 4
            // y=-PI/2 -> 5
            // x=PI -> 6
            // (с учётом возможных небольших погрешностей)
            const eps = 0.2;
            if (Math.abs(rotation.x) < eps && Math.abs(rotation.y) < eps) return 1;
            if (Math.abs(rotation.x) < eps && Math.abs(rotation.y - Math.PI/2) < eps) return 2;
            if (Math.abs(rotation.x + Math.PI/2) < eps && Math.abs(rotation.y) < eps) return 3;
            if (Math.abs(rotation.x - Math.PI/2) < eps && Math.abs(rotation.y) < eps) return 4;
            if (Math.abs(rotation.x) < eps && Math.abs(rotation.y + Math.PI/2) < eps) return 5;
            if (Math.abs(rotation.x - Math.PI) < eps && Math.abs(rotation.y) < eps) return 6;
            // Если не удалось определить, вернуть 1 по умолчанию
            return 1;
        }

        // Инициализация двух 3D-кубиков при загрузке
        window.addEventListener('DOMContentLoaded', () => {
            // Проверка загрузки игровых модулей
            setTimeout(() => {
                console.log('Проверка загрузки модулей...');
                
                if (typeof techniqueUtils === 'undefined') {
                    console.error('techniques.js не загружен!');
                } else {
                    console.log('✅ techniques.js загружен успешно');
                }
                
                if (typeof missionUtils === 'undefined') {
                    console.error('missions.js не загружен!');
                } else {
                    console.log('✅ missions.js загружен успешно');
                }
                
                if (typeof modifierUtils === 'undefined') {
                    console.error('modifiers.js не загружен!');
                } else {
                    console.log('✅ modifiers.js загружен успешно');
                }
                
                if (typeof duelUtils === 'undefined') {
                    console.error('duels.js не загружен!');
                } else {
                    console.log('✅ duels.js загружен успешно');
                }
                
                }, 100);
                
            setTimeout(() => {
                if (typeof THREE === 'undefined') {
                    console.error('Three.js не загружен!');
                    const err = document.createElement('div');
                    err.textContent = 'Ошибка: Three.js не загружен!';
                    err.style.color = 'red';
                    err.style.fontWeight = 'bold';
                    document.body.appendChild(err);
                    return;
                }
                const c1 = document.getElementById('dice3d-container1');
                const c2 = document.getElementById('dice3d-container2');
                if (!c1 || !c2) {
                    console.error('Контейнеры для кубиков не найдены!');
                    const err = document.createElement('div');
                    err.textContent = 'Ошибка: Контейнеры для кубиков не найдены!';
                    err.style.color = 'red';
                    err.style.fontWeight = 'bold';
                    document.body.appendChild(err);
                    return;
                }
                try {
                    init3DDicePair();
                } catch (e) {
                    console.error('Ошибка при инициализации 3D-кубиков:', e);
                    const err = document.createElement('div');
                    err.textContent = 'Ошибка при инициализации 3D-кубиков: ' + e;
                    err.style.color = 'red';
                    err.style.fontWeight = 'bold';
                    document.body.appendChild(err);
                }
            }, 200);
        });

        // Обновлённая функция для точек
        function getDiceDots(faceNumber, size = 128) {
            const dots = [];
            const center = size / 2;
            const offset = size * 0.28;
            switch (faceNumber) {
                case 1:
                    dots.push({ x: center, y: center });
                    break;
                case 2:
                    dots.push({ x: center - offset, y: center - offset });
                    dots.push({ x: center + offset, y: center + offset });
                    break;
                case 3:
                    dots.push({ x: center - offset, y: center - offset });
                    dots.push({ x: center, y: center });
                    dots.push({ x: center + offset, y: center + offset });
                    break;
                case 4:
                    dots.push({ x: center - offset, y: center - offset });
                    dots.push({ x: center + offset, y: center - offset });
                    dots.push({ x: center - offset, y: center + offset });
                    dots.push({ x: center + offset, y: center + offset });
                    break;
                case 5:
                    dots.push({ x: center - offset, y: center - offset });
                    dots.push({ x: center + offset, y: center - offset });
                    dots.push({ x: center, y: center });
                    dots.push({ x: center - offset, y: center + offset });
                    dots.push({ x: center + offset, y: center + offset });
                    break;
                case 6:
                    dots.push({ x: center - offset, y: center - offset });
                    dots.push({ x: center + offset, y: center - offset });
                    dots.push({ x: center - offset, y: center });
                    dots.push({ x: center + offset, y: center });
                    dots.push({ x: center - offset, y: center + offset });
                    dots.push({ x: center + offset, y: center + offset });
                    break;
            }
            return dots;
        }

        function fitRightBlockToBoard() {
            const board = document.getElementById('board');
            const rightBlock = document.getElementById('right-block');
            if (board && rightBlock) {
                const boardRect = board.getBoundingClientRect();
                const blockRect = rightBlock.getBoundingClientRect();
                const top = blockRect.top;
                const bottom = boardRect.bottom;
                const newHeight = Math.max(120, bottom - top);
                rightBlock.style.height = newHeight + 'px';
                rightBlock.style.maxHeight = newHeight + 'px';
            }
        }
        window.addEventListener('resize', fitRightBlockToBoard);
        const origCreateBoard = createBoard;
        createBoard = function() {
            origCreateBoard.apply(this, arguments);
            setTimeout(fitRightBlockToBoard, 0);
        };
        window.addEventListener('DOMContentLoaded', fitRightBlockToBoard);

        // При перестроении поля обновлять CSS-переменные для grid
        function updateBoardGridVars() {
            const board = document.getElementById('board');
            if (board) {
                board.style.setProperty('--board-width', boardWidth);
                board.style.setProperty('--board-height', boardHeight);
            }
        }
        // Вызвать после updateBoardSizeAndRestart и при инициализации
        const origUpdateBoardSizeAndRestart = updateBoardSizeAndRestart;
        updateBoardSizeAndRestart = function() {
            origUpdateBoardSizeAndRestart.apply(this, arguments);
            updateBoardGridVars();
        };
        window.addEventListener('DOMContentLoaded', updateBoardGridVars);

        // --- Модалка игрока ---
        function openPlayerModal(idx) {
          const p = players[idx];
          const html = `
            <h2><span class="player-icon">${p.img || '🙂'}</span> ${p.name}</h2>
            <div>Деньги: <b>${p.money} рё</b></div>
            <div>Чакра: <b>${p.chakra}</b></div>
            <div>Недвижимость: <b>${(boardCells.filter(cell => cell.owner === idx).length) || 0}</b></div>
            <div>Техники: <b>${(p.techniques ? p.techniques.length : 0)}</b></div>
            ${p.inJail ? `<div>Тюрьма: <b>${p.jailTurns} ход(ов)</b></div>` : ''}
          `;
          document.getElementById('player-modal-content').innerHTML = html;
          document.getElementById('player-modal-bg').classList.add('active');
        }
        function closePlayerModal() {
          document.getElementById('player-modal-bg').classList.remove('active');
        }
        // --- Перерисовка списка игроков ---
        function updateDisplay() {
          const statsList = document.getElementById('player-stats-list');
          statsList.innerHTML = '';
          const header = document.createElement('div');
          header.style.display = 'flex';
          header.style.alignItems = 'center';
          header.style.justifyContent = 'flex-start';
          header.style.fontWeight = 'bold';
          header.style.fontSize = '1.08em';
          header.style.color = '#ffd700';
          header.style.margin = '2px 0 8px 0';
          header.style.cursor = 'pointer';
          header.innerHTML = `<span>Все игроки</span><span style="font-size:1.2em; margin-left:8px;">${window.playersListCollapsed ? '⏵' : '⏷'}</span>`;
          header.onclick = function() {
              window.playersListCollapsed = !window.playersListCollapsed;
              updateDisplay();
          };
          statsList.appendChild(header);
          // --- Управление высотой блока ---
          const rightBlock = document.querySelector('.right-bottom-block');
          if (rightBlock) {
            if (window.playersListCollapsed) {
              rightBlock.style.height = '65px';
              rightBlock.style.minHeight = '0';
              rightBlock.style.maxHeight = '65px';
            } else {
              rightBlock.style.height = '';
              rightBlock.style.minHeight = '';
              rightBlock.style.maxHeight = '';
            }
          }
          if (window.playersListCollapsed) return;
          // --- Если идёт выбор персонажа, показываем 6 пустых строк ---
          if (window.isChoosingCharacter) {
            for (let i = 0; i < 6; i++) {
              const div = document.createElement('div');
              div.className = 'player-mini';
              div.style.height = '40px';
              div.style.margin = '4px 0';
              statsList.appendChild(div);
            }
            return;
          }
          // --- Список игроков ---
          players.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = 'player-mini' + (openedPlayerIdx === index ? ' active' : '');
            // 1. Строка с иконкой и именем
            const mainRow = document.createElement('div');
            mainRow.className = 'player-main-row';
            let status = '';
            if (index === currentPlayer) {
              status = '<span style="margin-left:6px; font-size:1.1em; color:#a259e6;">▶️</span>';
            } else if (p.inJail) {
              status = '<span title="В тюрьме" style="margin-left:6px; font-size:1.1em; color:#b71c1c;">⛓️</span>';
            }
            mainRow.innerHTML = `
              <span class="player-icon">${p.img || p.icon || '🙂'}</span>
              <span class="player-name">${p.name}${status}</span>
            `;
            div.appendChild(mainRow);
            div.onclick = () => {
              openedPlayerIdx = (openedPlayerIdx === index) ? null : index;
              updateDisplay();
            };
            if (openedPlayerIdx === index) {
              div.appendChild(createPlayerDetails(p, index));
            }
            statsList.appendChild(div);
          });
        }

        document.querySelectorAll('.cell').forEach(cell => {
          // Начальные координаты
          cell.style.position = 'absolute';
          if (!cell.style.left) cell.style.left = cell.offsetLeft + 'px';
          if (!cell.style.top) cell.style.top = cell.offsetTop + 'px';
          cell.setAttribute('data-x', parseInt(cell.style.left));
          cell.setAttribute('data-y', parseInt(cell.style.top));
        });

        interact('.cell')
          .draggable({
            listeners: {
              move (event) {
                const target = event.target;
                let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                target.style.left = x + 'px';
                target.style.top = y + 'px';
                target.setAttribute('data-x', x);
                target.setAttribute('data-y', y);
              }
            }
          })
          .resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
              move (event) {
                let { x, y } = event.target.dataset;
                x = parseFloat(x) || 0;
                y = parseFloat(y) || 0;
                event.target.style.width = event.rect.width + 'px';
                event.target.style.height = event.rect.height + 'px';
                // При ресайзе сдвигаем позицию, если resize слева/сверху
                x += event.deltaRect.left;
                y += event.deltaRect.top;
                event.target.style.left = x + 'px';
                event.target.style.top = y + 'px';
                event.target.setAttribute('data-x', x);
                event.target.setAttribute('data-y', y);
              }
            },
            modifiers: [
              interact.modifiers.restrictSize({
                min: { width: 40, height: 40 },
                max: { width: 200, height: 200 }
              })
            ]
          });

        // Гарантированно отключаем все игровые клики для .cell
        window.addEventListener('load', function() {
          document.querySelectorAll('.cell').forEach(cell => {
            cell.onclick = null;
            cell.removeAttribute('onclick');
            cell.addEventListener('click', function(e) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return false;
            }, true);
          });
        });

        // --- Drag для всего поля (только .board, через transform) ---
        window.addEventListener('DOMContentLoaded', function() {
          const board = document.querySelector('.board');
          if (board) {
            board.setAttribute('data-x', 0);
            board.setAttribute('data-y', 0);
            board.style.transform = 'translate(0px, 0px)';
          }
        });

        interact('.board').draggable({
          listeners: {
            move(event) {
              const target = event.target;
              let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
              let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
              target.style.transform = `translate(${x}px, ${y}px)`;
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);
            }
          }
        });

        // --- Drag и resize для #right-block (список игроков) ---
        window.addEventListener('DOMContentLoaded', function() {
          const block = document.getElementById('right-block');
          if (block) {
            block.setAttribute('data-x', 0);
            block.setAttribute('data-y', 0);
            block.style.transform = 'translate(0px, 0px)';
          }
        });

        interact('#right-block').draggable({
          listeners: {
            move(event) {
              const target = event.target;
              let x = (parseFloat(target.style.left) || 0) + event.dx;
              let y = (parseFloat(target.style.top) || 0) + event.dy;
              target.style.left = x + 'px';
              target.style.top = y + 'px';
            }
          }
        });

        // --- Пропорциональное масштабирование содержимого мини-блоков игроков при resize ---
        const BASE_PLAYER_CARD_HEIGHT = 56; // px, исходная высота мини-блока (подбери под свой дизайн)
        const BASE_FONT_SIZE = 18; // px, исходный font-size
        const BASE_ICON_SIZE = 24; // px, исходный размер эмодзи/иконки

        interact('#right-block').resizable({
          edges: { top: true, left: true, bottom: true, right: true },
          listeners: {
            move(event) {
              const target = event.target;
              let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
              let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
              target.style.width = newWidth + 'px';
              target.style.height = newHeight + 'px';
              target.style.maxWidth = newWidth + 'px';
              target.style.maxHeight = newHeight + 'px';
              // Растягиваем все карточки игроков синхронно по высоте и ширине
              const playerCards = target.querySelectorAll('.player-stats, .player-mini');
              if (playerCards.length > 0) {
                const cardHeight = (newHeight - 16) / playerCards.length;
                playerCards.forEach(card => {
                  card.style.height = cardHeight + 'px';
                  card.style.width = '100%';
                  card.style.display = 'flex';
                  card.style.flexDirection = 'column';
                  card.style.justifyContent = 'center';
                  // Масштабируем содержимое
                  const scale = cardHeight / BASE_PLAYER_CARD_HEIGHT;
                  card.style.fontSize = (BASE_FONT_SIZE * scale) + 'px';
                  // Эмодзи/иконки
                  card.querySelectorAll('.player-icon').forEach(icon => {
                    icon.style.fontSize = (BASE_ICON_SIZE * scale) + 'px';
                  });
                  // Если есть раскрытые статы — тоже масштабируем
                  card.querySelectorAll('.player-details, .player-stats-info').forEach(details => {
                    details.style.fontSize = (BASE_FONT_SIZE * scale * 0.95) + 'px';
                  });
                });
              }
            }
          },
          modifiers: [
            interact.modifiers.restrictSize({
              min: { width: 120, height: 80 },
              max: { width: 900, height: 900 }
            })
          ]
        });

        // --- Drag и resize для кнопки 'Бросить кубики' (#dice-button) ---
        window.addEventListener('DOMContentLoaded', function() {
          const btn = document.getElementById('dice-button');
          if (btn) {
            btn.setAttribute('data-x', 0);
            btn.setAttribute('data-y', 0);
            btn.style.transform = 'translate(0px, 0px)';
            btn.setAttribute('data-base-width', btn.offsetWidth);
            btn.setAttribute('data-base-height', btn.offsetHeight);
            btn.setAttribute('data-base-font', window.getComputedStyle(btn).fontSize);
          }
        });

        interact('#dice-button').draggable({
          listeners: {
            move(event) {
              const target = event.target;
              let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
              let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
              target.style.transform = `translate(${x}px, ${y}px)`;
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);
            }
          }
        });

        interact('#dice-button').resizable({
          edges: { top: true, left: true, bottom: true, right: true },
          listeners: {
            move(event) {
              const target = event.target;
              let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
              let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
              target.style.width = newWidth + 'px';
              target.style.height = newHeight + 'px';
              target.style.maxWidth = newWidth + 'px';
              target.style.maxHeight = newHeight + 'px';
              // Масштабируем текст кнопки пропорционально высоте
              const baseHeight = parseFloat(target.getAttribute('data-base-height')) || 48;
              const baseFont = parseFloat(target.getAttribute('data-base-font')) || 24;
              const scale = newHeight / baseHeight;
              target.style.fontSize = (baseFont * scale) + 'px';
            }
          },
          modifiers: [
            interact.modifiers.restrictSize({
              min: { width: 80, height: 32 },
              max: { width: 600, height: 200 }
            })
          ]
        });

        // --- Отключаю клики по кнопке 'Бросить кубики' (#dice-button) ---
        // window.addEventListener('DOMContentLoaded', function() {
        //   const btn = document.getElementById('dice-button');
        //   if (btn) {
        //     btn.onclick = function(e) { e.stopPropagation(); e.preventDefault(); };
        //     btn.onmousedown = function(e) { e.stopPropagation(); e.preventDefault(); };
        //     btn.ondblclick = function(e) { e.stopPropagation(); e.preventDefault(); };
        //     btn.oncontextmenu = function(e) { e.stopPropagation(); e.preventDefault(); };
        //     btn.addEventListener('click', function(e) { e.stopImmediatePropagation(); e.preventDefault(); }, true);
        //     btn.addEventListener('dblclick', function(e) { e.stopImmediatePropagation(); e.preventDefault(); }, true);
        //     btn.addEventListener('contextmenu', function(e) { e.stopImmediatePropagation(); e.preventDefault(); }, true);
        //     btn.addEventListener('keydown', function(e) {
        //       if (e.key === 'Enter' || e.key === ' ') { e.stopImmediatePropagation(); e.preventDefault(); }
        //     }, true);
        //   }
        // });

        // --- Drag для блока кубиков (оба кубика вместе) ---
        window.addEventListener('DOMContentLoaded', function() {
          const c1 = document.getElementById('dice3d-container1');
          const c2 = document.getElementById('dice3d-container2');
          if (c1 && c2 && !document.getElementById('dice-block')) {
            const diceBlock = document.createElement('div');
            diceBlock.id = 'dice-block';
            diceBlock.style.display = 'flex';
            diceBlock.style.gap = '8px';
            diceBlock.style.alignItems = 'center';
            diceBlock.setAttribute('data-x', 0);
            diceBlock.setAttribute('data-y', 0);
            diceBlock.style.transform = 'translate(0px, 0px)';
            c1.parentNode.insertBefore(diceBlock, c1);
            diceBlock.appendChild(c1);
            diceBlock.appendChild(c2);
          }
        });

        interact('#dice-block').draggable({
          listeners: {
            move(event) {
              const target = event.target;
              let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
              let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
              target.style.transform = `translate(${x}px, ${y}px)`;
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);
            }
          }
        });
        // Отключаю drag для отдельных кубиков (если был)
        // ... (оставь только drag для #dice-block) ...

        // --- Resize для блока кубиков с реальным изменением размера 3D-кубиков ---
        const BASE_DICE_BLOCK_WIDTH = 300; // px, исходная ширина блока (2 кубика по 140 + gap)
        const BASE_DICE_BLOCK_HEIGHT = 140; // px, исходная высота блока (высота кубика)

        // Сохраняем ссылки на three.js-рендереры
        window._diceRenderers = window._diceRenderers || {};
        function registerDiceRenderer(containerId, renderer) {
          window._diceRenderers[containerId] = renderer;
        }

        // Переопределяем create3DDice, чтобы сохранять renderer
        const origCreate3DDice = window.create3DDice;
        window.create3DDice = function(containerId, diceNum) {
          origCreate3DDice.apply(this, arguments);
          // Сохраняем renderer
          const container = document.getElementById(containerId);
          if (container && container.firstChild && container.firstChild.tagName === 'CANVAS') {
            // Находим renderer через глобальные переменные
            let renderer = null;
            if (diceNum === 1 && window.diceRenderer1) renderer = window.diceRenderer1;
            if (diceNum === 2 && window.diceRenderer2) renderer = window.diceRenderer2;
            if (renderer) registerDiceRenderer(containerId, renderer);
          }
        };

        interact('#dice-block').resizable({
          edges: { top: true, left: true, bottom: true, right: true },
          listeners: {
            move(event) {
              const target = event.target;
              let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
              let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
              target.style.width = newWidth + 'px';
              target.style.height = newHeight + 'px';
              target.style.maxWidth = newWidth + 'px';
              target.style.maxHeight = newHeight + 'px';
              // Вычисляем новые размеры для каждого кубика
              const c1 = target.querySelector('#dice3d-container1');
              const c2 = target.querySelector('#dice3d-container2');
              const diceW = newWidth / 2 - 4; // делим пополам, минус gap
              const diceH = newHeight;
              if (c1) {
                c1.style.width = diceW + 'px';
                c1.style.height = diceH + 'px';
                const r1 = window._diceRenderers['dice3d-container1'];
                if (r1) r1.setSize(diceW, diceH, false);
                const canvas1 = c1.querySelector('canvas');
                if (canvas1) { canvas1.style.width = diceW + 'px'; canvas1.style.height = diceH + 'px'; }
              }
              if (c2) {
                c2.style.width = diceW + 'px';
                c2.style.height = diceH + 'px';
                const r2 = window._diceRenderers['dice3d-container2'];
                if (r2) r2.setSize(diceW, diceH, false);
                const canvas2 = c2.querySelector('canvas');
                if (canvas2) { canvas2.style.width = diceW + 'px'; canvas2.style.height = diceH + 'px'; }
              }
            }
          },
          modifiers: [
            interact.modifiers.restrictSize({
              min: { width: 80, height: 40 },
              max: { width: 900, height: 400 }
            })
          ]
        });

        // === Сохранение и загрузка макета ===
        function getLayoutData() {
            // Сохраняем все элементы, которые можно двигать/масштабировать
            const layout = {};
            // Доска
            const board = document.querySelector('.board');
            layout.board = {
                x: parseFloat(board.getAttribute('data-x')) || 0,
                y: parseFloat(board.getAttribute('data-y')) || 0,
                width: board.offsetWidth,
                height: board.offsetHeight,
                transform: board.style.transform || '',
                gridColumns: board.style.gridTemplateColumns || '',
                gridRows: board.style.gridTemplateRows || ''
            };
            // Клетки
            layout.cells = [];
            document.querySelectorAll('.cell').forEach((cell, idx) => {
                layout.cells.push({
                    index: idx,
                    x: parseFloat(cell.getAttribute('data-x')) || 0,
                    y: parseFloat(cell.getAttribute('data-y')) || 0,
                    width: cell.offsetWidth,
                    height: cell.offsetHeight,
                    left: cell.style.left || '',
                    top: cell.style.top || '',
                    style: cell.getAttribute('style') || ''
                });
            });
            // Блок кубиков
            const diceBlock = document.getElementById('dice-block');
            if (diceBlock) {
                layout.diceBlock = {
                    x: parseFloat(diceBlock.getAttribute('data-x')) || 0,
                    y: parseFloat(diceBlock.getAttribute('data-y')) || 0,
                    width: diceBlock.offsetWidth,
                    height: diceBlock.offsetHeight,
                    style: diceBlock.getAttribute('style') || ''
                };
            }
            // Кнопка броска кубиков
            const diceBtn = document.getElementById('dice-button');
            if (diceBtn) {
                layout.diceButton = {
                    x: parseFloat(diceBtn.getAttribute('data-x')) || 0,
                    y: parseFloat(diceBtn.getAttribute('data-y')) || 0,
                    width: diceBtn.offsetWidth,
                    height: diceBtn.offsetHeight,
                    style: diceBtn.getAttribute('style') || ''
                };
            }
            // Кнопка завершения хода
            const endTurnBtn = document.getElementById('end-turn-button');
            if (endTurnBtn) {
                layout.endTurnButton = {
                    x: parseFloat(endTurnBtn.getAttribute('data-x')) || 0,
                    y: parseFloat(endTurnBtn.getAttribute('data-y')) || 0,
                    width: endTurnBtn.offsetWidth,
                    height: endTurnBtn.offsetHeight,
                    style: endTurnBtn.getAttribute('style') || ''
                };
            }
            // Колода техник (deck-block)
            const deckBlock = document.getElementById('deck-block');
            if (deckBlock) {
                layout.deckBlock = {
                    x: parseFloat(deckBlock.getAttribute('data-x')) || 0,
                    y: parseFloat(deckBlock.getAttribute('data-y')) || 0,
                    width: deckBlock.offsetWidth,
                    height: deckBlock.offsetHeight,
                    left: deckBlock.style.left || '',
                    top: deckBlock.style.top || '',
                    style: deckBlock.getAttribute('style') || ''
                };
            }
            // Колода миссий (missions-deck-block)
            const missionsDeckBlock = document.getElementById('missions-deck-block');
            if (missionsDeckBlock) {
                layout.missionsDeckBlock = {
                    x: parseFloat(missionsDeckBlock.getAttribute('data-x')) || 0,
                    y: parseFloat(missionsDeckBlock.getAttribute('data-y')) || 0,
                    width: missionsDeckBlock.offsetWidth,
                    height: missionsDeckBlock.offsetHeight,
                    left: missionsDeckBlock.style.left || '',
                    top: missionsDeckBlock.style.top || '',
                    style: missionsDeckBlock.getAttribute('style') || ''
                };
            }
            // Правая панель (список игроков)
            const rightBlock = document.getElementById('right-block');
            if (rightBlock) {
                layout.rightBlock = {
                    x: parseFloat(rightBlock.getAttribute('data-x')) || 0,
                    y: parseFloat(rightBlock.getAttribute('data-y')) || 0,
                    width: rightBlock.offsetWidth,
                    height: rightBlock.offsetHeight,
                    style: rightBlock.getAttribute('style') || ''
                };
            }
            // --- Сохраняем шапку ---
            const saveBlockData = (id) => {
                const el = document.getElementById(id);
                if (!el) return null;
                return {
                    left: el.style.left || '',
                    top: el.style.top || '',
                    width: el.style.width || '',
                    height: el.style.height || ''
                };
            };
            layout.gameTitleBlock = saveBlockData('game-title-block');
            layout.menuBlock = saveBlockData('menu-block');
            layout.boardFormBlock = saveBlockData('board-form-block');
            // layout-actions
            const layoutActions = document.getElementById('layout-actions');
            layout.layoutActions = {
                left: layoutActions.style.left || '',
                top: layoutActions.style.top || '',
                width: layoutActions.style.width || '',
                height: layoutActions.style.height || ''
            };
            // player-panel
            const playerPanel = document.getElementById('player-panel');
            layout.playerPanel = {
                left: playerPanel.style.left || '',
                top: playerPanel.style.top || '',
                width: playerPanel.style.width || '',
                height: playerPanel.style.height || ''
            };
            // playerPanelCollapsed (свёрнутость панели)
            const body = document.getElementById('player-panel-body');
            layout.playerPanelCollapsed = (body && body.style.display === 'none');
            return layout;
        }

        function applyLayoutData(layout) {
            // Доска
            const board = document.querySelector('.board');
            if (layout.board) {
                board.setAttribute('data-x', layout.board.x);
                board.setAttribute('data-y', layout.board.y);
                board.style.transform = layout.board.transform || `translate(${layout.board.x}px, ${layout.board.y}px)`;
                if (layout.board.gridColumns) board.style.gridTemplateColumns = layout.board.gridColumns;
                if (layout.board.gridRows) board.style.gridTemplateRows = layout.board.gridRows;
                if (layout.board.width) board.style.width = layout.board.width + 'px';
                if (layout.board.height) board.style.height = layout.board.height + 'px';
            }
            // Клетки
            if (layout.cells) {
                document.querySelectorAll('.cell').forEach((cell, idx) => {
                    const data = layout.cells[idx];
                    if (data) {
                        cell.setAttribute('data-x', data.x);
                        cell.setAttribute('data-y', data.y);
                        cell.style.left = data.left || (data.x + 'px');
                        cell.style.top = data.top || (data.y + 'px');
                        if (data.width) cell.style.width = data.width + 'px';
                        if (data.height) cell.style.height = data.height + 'px';
                        if (data.style) cell.setAttribute('style', data.style);
                    }
                });
            }
            // Блок кубиков
            const diceBlock = document.getElementById('dice-block');
            if (diceBlock && layout.diceBlock) {
                diceBlock.setAttribute('data-x', layout.diceBlock.x);
                diceBlock.setAttribute('data-y', layout.diceBlock.y);
                if (layout.diceBlock.style) diceBlock.setAttribute('style', layout.diceBlock.style);
                if (layout.diceBlock.width) diceBlock.style.width = layout.diceBlock.width + 'px';
                if (layout.diceBlock.height) diceBlock.style.height = layout.diceBlock.height + 'px';
            }
            // Кнопка броска кубиков
            const diceBtn = document.getElementById('dice-button');
            if (diceBtn && layout.diceButton) {
                diceBtn.setAttribute('data-x', layout.diceButton.x);
                diceBtn.setAttribute('data-y', layout.diceButton.y);
                if (layout.diceButton.style) diceBtn.setAttribute('style', layout.diceButton.style);
                if (layout.diceButton.width) diceBtn.style.width = layout.diceButton.width + 'px';
                if (layout.diceButton.height) diceBtn.style.height = layout.diceButton.height + 'px';
            }
            // Кнопка завершения хода
            const endTurnBtn = document.getElementById('end-turn-button');
            if (endTurnBtn && layout.endTurnButton) {
                endTurnBtn.setAttribute('data-x', layout.endTurnButton.x);
                endTurnBtn.setAttribute('data-y', layout.endTurnButton.y);
                if (layout.endTurnButton.style) endTurnBtn.setAttribute('style', layout.endTurnButton.style);
                if (layout.endTurnButton.width) endTurnBtn.style.width = layout.endTurnButton.width + 'px';
                if (layout.endTurnButton.height) endTurnBtn.style.height = layout.endTurnButton.height + 'px';
            }
            // Колода техник (deck-block)
            const deckBlock = document.getElementById('deck-block');
            if (deckBlock && layout.deckBlock) {
                deckBlock.setAttribute('data-x', layout.deckBlock.x);
                deckBlock.setAttribute('data-y', layout.deckBlock.y);
                if (layout.deckBlock.style) deckBlock.setAttribute('style', layout.deckBlock.style);
                if (layout.deckBlock.width) deckBlock.style.width = layout.deckBlock.width + 'px';
                if (layout.deckBlock.height) deckBlock.style.height = layout.deckBlock.height + 'px';
                // === ЗАЩИТА: не перезаписываем позиции, если колода уже имеет координаты ===
                if (layout.deckBlock.left && (!deckBlock.style.left || deckBlock.style.left === '0px')) {
                    deckBlock.style.left = layout.deckBlock.left;
                }
                if (layout.deckBlock.top && (!deckBlock.style.top || deckBlock.style.top === '0px')) {
                    deckBlock.style.top = layout.deckBlock.top;
                }
            }
            // Колода миссий (missions-deck-block)
            const missionsDeckBlock = document.getElementById('missions-deck-block');
            if (missionsDeckBlock && layout.missionsDeckBlock) {
                missionsDeckBlock.setAttribute('data-x', layout.missionsDeckBlock.x);
                missionsDeckBlock.setAttribute('data-y', layout.missionsDeckBlock.y);
                if (layout.missionsDeckBlock.style) missionsDeckBlock.setAttribute('style', layout.missionsDeckBlock.style);
                if (layout.missionsDeckBlock.width) missionsDeckBlock.style.width = layout.missionsDeckBlock.width + 'px';
                if (layout.missionsDeckBlock.height) missionsDeckBlock.style.height = layout.missionsDeckBlock.height + 'px';
                // === ЗАЩИТА: не перезаписываем позиции, если колода уже имеет координаты ===
                if (layout.missionsDeckBlock.left && (!missionsDeckBlock.style.left || missionsDeckBlock.style.left === '0px')) {
                    missionsDeckBlock.style.left = layout.missionsDeckBlock.left;
                }
                if (layout.missionsDeckBlock.top && (!missionsDeckBlock.style.top || missionsDeckBlock.style.top === '0px')) {
                    missionsDeckBlock.style.top = layout.missionsDeckBlock.top;
                }
            }
            // Правая панель
            const rightBlock = document.getElementById('right-block');
            if (rightBlock && layout.rightBlock) {
                rightBlock.setAttribute('data-x', layout.rightBlock.x);
                rightBlock.setAttribute('data-y', layout.rightBlock.y);
                if (layout.rightBlock.style) rightBlock.setAttribute('style', layout.rightBlock.style);
                if (layout.rightBlock.width) rightBlock.style.width = layout.rightBlock.width + 'px';
                if (layout.rightBlock.height) rightBlock.style.height = layout.rightBlock.height + 'px';
            }
            // --- Восстанавливаем шапку ---
            const restoreBlockData = (id, data) => {
                const el = document.getElementById(id);
                if (!el || !data) return;
                if (data.left) el.style.left = data.left;
                if (data.top) el.style.top = data.top;
                if (data.width) el.style.width = data.width;
                if (data.height) el.style.height = data.height;
            };
            restoreBlockData('game-title-block', layout.gameTitleBlock);
            restoreBlockData('menu-block', layout.menuBlock);
            restoreBlockData('board-form-block', layout.boardFormBlock);
            // layout-actions
            if (layout.layoutActions) {
                const la = document.getElementById('layout-actions');
                if (layout.layoutActions.left) la.style.left = layout.layoutActions.left;
                if (layout.layoutActions.top) la.style.top = layout.layoutActions.top;
                if (layout.layoutActions.width) la.style.width = layout.layoutActions.width;
                if (layout.layoutActions.height) la.style.height = layout.layoutActions.height;
            }
            // player-panel
            if (layout.playerPanel) {
                const pp = document.getElementById('player-panel');
                if (layout.playerPanel.left) pp.style.left = layout.playerPanel.left;
                if (layout.playerPanel.top) pp.style.top = layout.playerPanel.top;
                if (layout.playerPanel.width) pp.style.width = layout.playerPanel.width;
                if (layout.playerPanel.height) pp.style.height = layout.playerPanel.height;
            }
            // playerPanelCollapsed (свёрнутость панели)
            if (typeof layout.playerPanelCollapsed !== 'undefined') {
                const body = document.getElementById('player-panel-body');
                const toggle = document.getElementById('player-panel-toggle');
                if (layout.playerPanelCollapsed) {
                    body.style.display = 'none';
                    toggle.textContent = '⏵';
                } else {
                    body.style.display = '';
                    toggle.textContent = '⏷';
                }
            }
        }

        function downloadLayout() {
            const layout = getLayoutData();
            const blob = new Blob([JSON.stringify(layout, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'monopoly_layout.json';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function uploadLayoutFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const layout = JSON.parse(e.target.result);
                    applyLayoutData(layout);
                    showMessage('Макет успешно загружен!');
                } catch (err) {
                    showMessage('Ошибка загрузки макета: ' + err);
                }
            };
            reader.readAsText(file);
        }

        document.getElementById('save-layout-btn').addEventListener('click', downloadLayout);
        document.getElementById('load-layout-btn').addEventListener('click', function() {
            document.getElementById('load-layout-input').click();
        });
        document.getElementById('load-layout-input').addEventListener('change', function(e) {
            if (e.target.files && e.target.files[0]) {
                uploadLayoutFile(e.target.files[0]);
            }
        });

        function hideWindow(id) {
          document.getElementById(id).style.display = 'none';
        }
        function showWindow(id) {
          document.getElementById(id).style.display = 'block';
        }
        // --- Drag & Resize для новых окон ---
        ['trade-window','stats-window'].forEach(function(winId) {
          window.addEventListener('DOMContentLoaded', function() {
            const win = document.getElementById(winId);
            if (win) {
              win.setAttribute('data-x', parseFloat(win.style.left)||0);
              win.setAttribute('data-y', parseFloat(win.style.top)||0);
              win.style.transform = `translate(0px,0px)`;
            }
          });
          interact('#'+winId).draggable({
            listeners: {
              move(event) {
                const target = event.target;
                let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                target.style.left = x + 'px';
                target.style.top = y + 'px';
                target.setAttribute('data-x', x);
                target.setAttribute('data-y', y);
              }
            }
          }).resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
              move(event) {
                const target = event.target;
                let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
                let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
                target.style.width = newWidth + 'px';
                target.style.height = newHeight + 'px';
              }
            },
            modifiers: [
              interact.modifiers.restrictSize({
                min: { width: 180, height: 80 },
                max: { width: 900, height: 900 }
              })
            ]
          });
        });
        // --- Сохраняем и восстанавливаем окна в макете ---
        const origGetLayoutData = getLayoutData;
        getLayoutData = function() {
          const layout = origGetLayoutData();
          // Trade window
          const trade = document.getElementById('trade-window');
          if (trade) {
            layout.tradeWindow = {
              x: parseFloat(trade.style.left)||0,
              y: parseFloat(trade.style.top)||0,
              width: parseFloat(trade.style.width)||trade.offsetWidth,
              height: parseFloat(trade.style.height)||trade.offsetHeight,
              visible: trade.style.display !== 'none'
            };
          }
          // Stats window
          const stats = document.getElementById('stats-window');
          if (stats) {
            layout.statsWindow = {
              x: parseFloat(stats.style.left)||0,
              y: parseFloat(stats.style.top)||0,
              width: parseFloat(stats.style.width)||stats.offsetWidth,
              height: parseFloat(stats.style.height)||stats.offsetHeight,
              visible: stats.style.display !== 'none'
            };
          }
          // playerPanelCollapsed (свёрнутость панели)
          const body = document.getElementById('player-panel-body');
          layout.playerPanelCollapsed = (body && body.style.display === 'none');
          return layout;
        };

        // --- Базовый макет (layout) ---
        const BASE_LAYOUT = {"board":{"x":240.79998779296875,"y":52.00001525878906,"width":800,"height":640,"transform":"translate(240.8px, 52px)","gridColumns":"repeat(10, 80px)","gridRows":"repeat(8, 80px)"},"cells":[{"index":0,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 224, 130); grid-area: 1 / 1;"},{"index":1,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(247, 200, 115); grid-area: 1 / 2;"},{"index":2,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 127, 80); grid-area: 1 / 3;"},{"index":3,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(247, 200, 115); grid-area: 1 / 4;"},{"index":4,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(179, 229, 252); grid-area: 1 / 5;"},{"index":5,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(189, 183, 107); grid-area: 1 / 6;"},{"index":6,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 127, 80); grid-area: 1 / 7;"},{"index":7,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(189, 183, 107); grid-area: 1 / 8;"},{"index":8,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(189, 183, 107); grid-area: 1 / 9;"},{"index":9,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(68, 68, 68); grid-area: 1 / 10;"},{"index":10,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(129, 199, 132); grid-area: 2 / 1;"},{"index":11,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(136, 136, 136); grid-area: 2 / 10;"},{"index":12,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(129, 199, 132); grid-area: 3 / 1;"},{"index":13,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(79, 195, 247); grid-area: 3 / 10;"},{"index":14,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 213, 79); grid-area: 4 / 1;"},{"index":15,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(79, 195, 247); grid-area: 4 / 10;"},{"index":16,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(129, 199, 132); grid-area: 5 / 1;"},{"index":17,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 127, 80); grid-area: 5 / 10;"},{"index":18,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(206, 147, 216); grid-area: 6 / 1;"},{"index":19,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(79, 195, 247); grid-area: 6 / 10;"},{"index":20,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(229, 115, 115); grid-area: 7 / 1;"},{"index":21,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(179, 229, 252); grid-area: 7 / 10;"},{"index":22,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(189, 189, 189); grid-area: 8 / 1;"},{"index":23,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(229, 115, 115); grid-area: 8 / 2;"},{"index":24,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(144, 202, 249); grid-area: 8 / 3;"},{"index":25,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 127, 80); grid-area: 8 / 4;"},{"index":26,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 183, 77); grid-area: 8 / 5;"},{"index":27,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 112, 67); grid-area: 8 / 6;"},{"index":28,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 183, 77); grid-area: 8 / 7;"},{"index":29,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 183, 77); grid-area: 8 / 8;"},{"index":30,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(255, 127, 80); grid-area: 8 / 9;"},{"index":31,"x":0,"y":0,"width":80,"height":80,"left":"","top":"","style":"background-color: rgb(161, 136, 127); grid-area: 8 / 10;"}],"diceBlock":{"x":0, "y": 0, "width": 240, "height": 140, "style": "position: absolute; left: 1062.8px; top: 10px; width: 240px; height: 140px; display: flex; gap: 8px; align-items: center; z-index: 2000;"},"diceButton":{"x":0, "y": 0, "width": 158, "height": 45, "style": "position: absolute; left: 1103.8px; top: 165px; width: 158px; height: 45px; z-index: 2000; font-size: 18px; display: flex; align-items: center; justify-content: center; text-align: center; background: #4caf50; color: #fff; border-radius: 25px; border: none; font-weight: bold; cursor: pointer;"},"endTurnButton":{"x":183.9998779296875,"y":73.60000610351562,"width":163,"height":44,"style":"position: absolute; left: 1100px; top: 180px; width: 163px; height: 44px; z-index: 2000; font-size: 20.2971px; display: flex; align-items: center; justify-content: center; text-align: center; transform: translate(184px, 73.6px); max-width: 163.2px; max-height: 44.4px;"},"deckBlock":{"x":0,"y":0,"width":87,"height":132,"left":"559px","top":"301.2px","style":"position: absolute; width: 87px; height: 132px; z-index: 3000; left: 559px; top: 301.2px;"},"missionsDeckBlock":{"x":0,"y":0,"width":87,"height":127,"left":"1002.8px","top":"303.2px","style":"position: absolute; width: 87px; height: 127px; z-index: 3000; left: 1002.8px; top: 303.2px;"},"rightBlock":{"x":1072.8,"y":319.0,"width":190,"height":373,"style":"position: absolute; left: 1087.8px; top: 319px; width: 190px; height: 373px; pointer-events: auto; z-index: 2000;"},"gameTitleBlock":{"left":"669.6px","top":"8.80001px","width":"","height":""},"menuBlock":{"left":"50.4px","top":"24px","width":"323.288px","height":"41.6px"},"boardFormBlock":{"left":"1092.8px","top":"17.6px","width":"420.288px","height":"54.4px"},"layoutActions":{"left":"526.4px","top":"572px","width":"204.8px","height":"44.7875px"},"playerPanel":{"left":"22.4px","top":"625.6px","width":"355px","height":""},"playerPanelCollapsed":true,"tradeWindow":{"x":6.4,"y":237.6,"width":320,"visible":false},"statsWindow":{"x":582.4,"y":219.2,"width":340,"visible":false},"diceButton": {"x": 0, "y": 0, "width": 158, "height": 45, "style": "position: absolute; left: 1103.8px; top: 165px; width: 158px; height: 45px; z-index: 2000; font-size: 18px; display: flex; align-items: center; justify-content: center; text-align: center; background: #4caf50; color: #fff; border-radius: 25px; border: none; font-weight: bold; cursor: pointer;"}};

        window.addEventListener('DOMContentLoaded', function() {
          // ... существующая инициализация ...
          setTimeout(function() {
            applyLayoutData(BASE_LAYOUT);
          }, 0);
        });

        // === DRAG/RESIZE GAME TITLE ===
        document.addEventListener('DOMContentLoaded', function() {
            interact('#game-title-block')
                .draggable({
                    listeners: {
                        move (event) {
                            const target = event.target;
                            const x = (parseFloat(target.style.left)||0) + event.dx;
                            const y = (parseFloat(target.style.top)||0) + event.dy;
                            target.style.left = x + 'px';
                            target.style.top = y + 'px';
                        }
                    }
                })
                .resizable({
                    edges: { left: true, right: true, bottom: true, top: true },
                    listeners: {
                        move (event) {
                            let { x, y } = event.target.dataset;
                            x = parseFloat(x)||parseFloat(event.target.style.left)||0;
                            y = parseFloat(y)||parseFloat(event.target.style.top)||0;
                            event.target.style.width = event.rect.width + 'px';
                            event.target.style.height = event.rect.height + 'px';
                            event.target.style.left = (x + event.deltaRect.left) + 'px';
                            event.target.style.top = (y + event.deltaRect.top) + 'px';
                        }
                    },
                    modifiers: [
                        interact.modifiers.restrictSize({ min: { width: 120, height: 40 } })
                    ],
                    inertia: true
                });
        });

        // === DRAG MENU BLOCK ===
        document.addEventListener('DOMContentLoaded', function() {
            interact('#menu-block')
                .draggable({
                    listeners: {
                        move (event) {
                            const target = event.target;
                            const x = (parseFloat(target.style.left)||0) + event.dx;
                            const y = (parseFloat(target.style.top)||0) + event.dy;
                            target.style.left = x + 'px';
                            target.style.top = y + 'px';
                        }
                    }
                });
        });

        // === DRAG/RESIZE BOARD FORM BLOCK ===
        document.addEventListener('DOMContentLoaded', function() {
            interact('#board-form-block')
                .draggable({
                    listeners: {
                        move (event) {
                            const target = event.target;
                            const x = (parseFloat(target.style.left)||0) + event.dx;
                            const y = (parseFloat(target.style.top)||0) + event.dy;
                            target.style.left = x + 'px';
                            target.style.top = y + 'px';
                        }
                    }
                })
                .resizable({
                    edges: { left: true, right: true, bottom: true, top: true },
                    listeners: {
                        move (event) {
                            let { x, y } = event.target.dataset;
                            x = parseFloat(x)||parseFloat(event.target.style.left)||0;
                            y = parseFloat(y)||parseFloat(event.target.style.top)||0;
                            event.target.style.width = event.rect.width + 'px';
                            event.target.style.height = event.rect.height + 'px';
                            event.target.style.left = (x + event.deltaRect.left) + 'px';
                            event.target.style.top = (y + event.deltaRect.top) + 'px';
                        }
                    },
                    modifiers: [
                        interact.modifiers.restrictSize({ min: { width: 220, height: 40 } })
                    ],
                    inertia: true
                });
        });

        document.addEventListener('DOMContentLoaded', function() {
            // ... существующий код ...
            // --- Переключатели для окон ---
            function toggleWindow(id) {
                const win = document.getElementById(id);
                if (!win) return;
                win.style.display = (win.style.display === 'none' || win.style.display === '') ? 'block' : 'none';
            }
            document.getElementById('help-btn').onclick = function() { toggleWindow('help-window'); };
            document.getElementById('stats-btn').onclick = function() { toggleWindow('stats-window'); };
            document.getElementById('trade-btn').onclick = function() { toggleWindow('trade-window'); };
        });

        // --- Панель игрока: сворачивание ---
        document.getElementById('player-panel-toggle').onclick = function() {
            const body = document.getElementById('player-panel-body');
            if (body.style.display === 'none') {
                body.style.display = '';
                this.textContent = '⏷';
                if (typeof getLayoutData === 'function') {
                    let layout = getLayoutData();
                    layout.playerPanelCollapsed = false;
                }
            } else {
                body.style.display = 'none';
                this.textContent = '⏵';
                if (typeof getLayoutData === 'function') {
                    let layout = getLayoutData();
                    layout.playerPanelCollapsed = true;
                }
            }
        };
        // --- Пример заполнения техник, миссий, эффектов ---
        function renderPlayerPanel(player) {
            window.lastRenderedPlayer = player;
            document.getElementById('player-avatar').textContent = player.avatar || '🥷';
            document.getElementById('player-name').textContent = player.name || 'Наруто';
            document.getElementById('player-character').textContent = player.character || 'Узумаки';
            document.getElementById('player-money').textContent = player.money;
            document.getElementById('player-chakra').textContent = player.chakra;
            document.getElementById('player-chakra-max').textContent = player.chakraMax;
            document.getElementById('player-ip').textContent = player.influencePoints || 0;
            // Техники: только закреплённые
            const techDiv = document.getElementById('player-techniques');
            techDiv.innerHTML = '';
            techDiv.style.display = 'flex';
            techDiv.style.flexDirection = 'column';
            techDiv.style.gap = '8px';
            const ability = charAbilities[player.name];
            if (ability) {
                const el = document.createElement('div');
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.gap = '8px';
                el.style.background = '#44485a';
                el.style.color = '#ffd54f';
                el.style.fontWeight = '700';
                el.style.borderRadius = '8px';
                el.style.padding = '2px 10px 2px 6px';
                el.style.boxShadow = '0 1px 4px #0003';
                el.innerHTML = `<span style=\"font-size:18px;\">${ability.icon}</span><span>${ability.name}</span>`;
                // Tooltip для дефолтной техники
                el.onclick = function(e) {
                    const tooltip = document.getElementById('ability-tooltip');
                    const content = document.getElementById('ability-tooltip-content');
                    if (!tooltip || !content) return;
                    if (tooltip.style.display === 'block' && tooltip._openedBy === el) {
                        tooltip.style.display = 'none';
                        tooltip._openedBy = null;
                        return;
                    }
                    content.innerHTML = `<div style=\"font-weight:700; font-size:1.13em; margin-bottom:6px; color:#ffd54f; display:flex; align-items:center; gap:8px;\"><span style=\"font-size:1.2em;\">${ability.icon}</span> ${ability.name}</div><div style=\"color:#ffe082; margin-bottom:4px;\">${ability.description||''}</div>`;
                    const rect = el.getBoundingClientRect();
                    tooltip.style.left = (rect.left + window.scrollX) + 'px';
                    tooltip.style.top = (rect.bottom + 8 + window.scrollY) + 'px';
                    tooltip.style.display = 'block';
                    tooltip._openedBy = el;
                    setTimeout(() => {
                        document.addEventListener('mousedown', closeTooltip, {once:true});
                        document.addEventListener('touchstart', closeTooltip, {once:true});
                    }, 0);
                    function closeTooltip(ev) {
                        if (!tooltip.contains(ev.target) && !el.contains(ev.target)) {
                            tooltip.style.display = 'none';
                            tooltip._openedBy = null;
                        }
                    }
                };
                // Кнопка "Активировать" справа
                const btnRow = document.createElement('div');
                btnRow.style.display = 'flex';
                btnRow.style.marginLeft = 'auto';
                const activateBtn = document.createElement('button');
                activateBtn.textContent = 'Активировать';
                activateBtn.disabled = false;
                activateBtn.style.fontSize = '13px';
                activateBtn.style.background = '#7ecbff';
                activateBtn.style.color = '#23243a';
                activateBtn.style.fontWeight = '700';
                activateBtn.style.border = 'none';
                activateBtn.style.borderRadius = '6px';
                activateBtn.style.cursor = 'pointer';
                activateBtn.style.padding = '4px 14px';
                activateBtn.onclick = function(e) {
                    e.stopPropagation();
                    if (typeof activateTechnique === 'function') activateTechnique(ability);
                    else showMessage(`Техника '${ability.name}' активирована!`);
                };
                btnRow.appendChild(activateBtn);
                el.appendChild(btnRow);
                techDiv.appendChild(el);
            }
            // Остальные закреплённые техники
            if (player.pinnedTechniques && player.pinnedTechniques.length) {
                // Импортируем справочник техник (глобально или через window.techniques)
                const allTechs = (typeof techniques !== 'undefined') ? techniques : (window.techniques || []);
                // Фильтруем pinnedTechniques: дефолтная техника не может быть закреплена
                const allPinned = player.pinnedTechniques.filter(name => !(ability && ability.name === name)).map(name => {
                    return allTechs.find(t => t.name === name) || player.techniques.find(t => t.name === name);
                }).filter(Boolean);
                allPinned.forEach(tech => {
                    const el = document.createElement('div');
                    el.style.display = 'flex';
                    el.style.alignItems = 'center';
                    el.style.gap = '8px';
                    el.style.background = tech.canActivate ? '#263b5e' : '#44485a';
                    el.style.color = tech.canActivate ? '#7ecbff' : '#bbb';
                    el.style.fontWeight = '700';
                    el.style.borderRadius = '8px';
                    el.style.padding = '2px 10px 2px 6px';
                    el.style.boxShadow = '0 1px 4px #0003';
                    el.innerHTML = `<span style=\"font-size:18px;\">${tech.icon||'🌀'}</span><span>${tech.name}</span>`;
                    // Tooltip для закреплённой техники
                    el.onclick = function(e) {
                        const tooltip = document.getElementById('ability-tooltip');
                        const content = document.getElementById('ability-tooltip-content');
                        if (!tooltip || !content) return;
                        if (tooltip.style.display === 'block' && tooltip._openedBy === el) {
                            tooltip.style.display = 'none';
                            tooltip._openedBy = null;
                            return;
                        }
                        content.innerHTML = `<div style=\"font-weight:700; font-size:1.13em; margin-bottom:6px; color:#ffd54f; display:flex; align-items:center; gap:8px;\"><span style=\"font-size:1.2em;\">${tech.icon||'🌀'}</span> ${tech.name}</div><div style=\"color:#ffe082; margin-bottom:4px;\">${tech.description||''}</div>` + (tech.chakraCost ? `<div style=\"color:#b39ddb; font-size:0.98em;\">Чакра: ${tech.chakraCost}</div>` : '');
                        const rect = el.getBoundingClientRect();
                        tooltip.style.left = (rect.left + window.scrollX) + 'px';
                        tooltip.style.top = (rect.bottom + 8 + window.scrollY) + 'px';
                        tooltip.style.display = 'block';
                        tooltip._openedBy = el;
                        setTimeout(() => {
                            document.addEventListener('mousedown', closeTooltip, {once:true});
                            document.addEventListener('touchstart', closeTooltip, {once:true});
                        }, 0);
                        function closeTooltip(ev) {
                            if (!tooltip.contains(ev.target) && !el.contains(ev.target)) {
                                tooltip.style.display = 'none';
                                tooltip._openedBy = null;
                            }
                        }
                    };
                    // Кнопки справа
                    const btnRow = document.createElement('div');
                    btnRow.style.display = 'flex';
                    btnRow.style.gap = '8px';
                    btnRow.style.marginLeft = 'auto';
                    btnRow.style.alignItems = 'center';
                    // Кнопка "Активировать" для обычных техник
                    if (!tech.type || tech.type === 'temporary' || tech.type === 'instant') {
                      const activateBtn = document.createElement('button');
                      activateBtn.textContent = 'Активировать';
                      activateBtn.disabled = false;
                      activateBtn.style.fontSize = '13px';
                      activateBtn.style.background = '#7ecbff';
                      activateBtn.style.color = '#23243a';
                      activateBtn.style.fontWeight = '700';
                      activateBtn.style.border = 'none';
                      activateBtn.style.borderRadius = '6px';
                      activateBtn.style.cursor = 'pointer';
                      activateBtn.style.padding = '4px 14px';
                      activateBtn.onclick = function(e) {
                        e.stopPropagation();
                        if (typeof activateTechnique === 'function') activateTechnique(tech);
                        else showMessage(`Техника '${tech.name}' активирована!`);
                      };
                      btnRow.appendChild(activateBtn);
                    }
                    // Кнопка удаления
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '×';
                    removeBtn.title = 'Убрать из панели';
                    removeBtn.style.background = 'none';
                    removeBtn.style.border = 'none';
                    removeBtn.style.color = '#ff5252';
                    removeBtn.style.fontSize = '18px';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.padding = '0 10px 0 10px';
                    removeBtn.onclick = function(e) {
                      e.stopPropagation();
                      player.pinnedTechniques = player.pinnedTechniques.filter(n => n !== tech.name);
                      renderPlayerPanel(player);
                    };
                    btnRow.appendChild(removeBtn);
                    el.appendChild(btnRow);
                    techDiv.appendChild(el);
                });
            }
            // Миссии
            const missionsDiv = document.getElementById('player-missions');
            missionsDiv.innerHTML = '';
            player.missions.forEach(mis => {
                const el = document.createElement('div');
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.gap = '4px';
                el.style.background = '#ffd54f';
                el.style.color = '#23243a';
                el.style.fontWeight = '700';
                el.style.borderRadius = '8px';
                el.style.padding = '2px 10px 2px 6px';
                el.style.boxShadow = '0 1px 4px #ffd54f33';
                el.innerHTML = `<span style="font-size:18px;">${mis.icon||'🎯'}</span><span>${mis.name}</span>`;
                missionsDiv.appendChild(el);
            });
            // Эффекты
            const effDiv = document.getElementById('player-effects');
            effDiv.innerHTML = '';
            player.effects.forEach(eff => {
                const el = document.createElement('div');
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.gap = '4px';
                el.style.background = '#a5d6a7';
                el.style.color = '#23243a';
                el.style.fontWeight = '700';
                el.style.borderRadius = '8px';
                el.style.padding = '2px 10px 2px 6px';
                el.style.boxShadow = '0 1px 4px #a5d6a733';
                el.innerHTML = `<span style="font-size:18px;">${eff.icon||'✨'}</span><span>${eff.name}</span>`;
                effDiv.appendChild(el);
            });
            
            // Обновляем таймер владения башней Хокаге
            updateTowerOwnershipTimer(player);
        }
        // --- Пример данных игрока ---
        // Не вызываем renderPlayerPanel здесь, так как выбранный игрок еще не определен

        // --- Drag для панели игрока ---
        interact('#player-panel').draggable({
            allowFrom: '#player-panel-header',
            listeners: {
                move (event) {
                    const target = event.target;
                    const x = (parseFloat(target.style.left)||0) + event.dx;
                    const y = (parseFloat(target.style.top)||0) + event.dy;
                    target.style.left = x + 'px';
                    target.style.top = y + 'px';
                }
            }
        });

        // --- Drag для menu-block ---
        interact('#menu-block').draggable({
            allowFrom: '#menu-block',
            listeners: {
                move (event) {
                    const target = event.target;
                    const x = (parseFloat(target.style.left)||0) + event.dx;
                    const y = (parseFloat(target.style.top)||0) + event.dy;
                    target.style.left = x + 'px';
                    target.style.top = y + 'px';
                }
            }
        }).resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
                move (event) {
                    let { x, y } = event.target.dataset;
                    x = parseFloat(x)||parseFloat(event.target.style.left)||0;
                    y = parseFloat(y)||parseFloat(event.target.style.top)||0;
                    event.target.style.width = event.rect.width + 'px';
                    event.target.style.height = event.rect.height + 'px';
                    x += event.deltaRect.left;
                    y += event.deltaRect.top;
                    event.target.style.left = x + 'px';
                    event.target.style.top = y + 'px';
                    event.target.dataset.x = x;
                    event.target.dataset.y = y;
                }
            },
            modifiers: [
                interact.modifiers.restrictSize({ min: { width: 180, height: 40 } })
            ]
        });
        // --- Drag & Resize для layout-actions ---
        interact('#layout-actions').draggable({
            allowFrom: '#layout-actions',
            listeners: {
                move (event) {
                    const target = event.target;
                    const x = (parseFloat(target.style.left)||0) + event.dx;
                    const y = (parseFloat(target.style.top)||0) + event.dy;
                    target.style.left = x + 'px';
                    target.style.top = y + 'px';
                }
            }
        }).resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
                move (event) {
                    let { x, y } = event.target.dataset;
                    x = parseFloat(x)||parseFloat(event.target.style.left)||0;
                    y = parseFloat(y)||parseFloat(event.target.style.top)||0;
                    event.target.style.width = event.rect.width + 'px';
                    event.target.style.height = event.rect.height + 'px';
                    x += event.deltaRect.left;
                    y += event.deltaRect.top;
                    event.target.style.left = x + 'px';
                    event.target.style.top = y + 'px';
                    event.target.dataset.x = x;
                    event.target.dataset.y = y;
                }
            },
            modifiers: [
                interact.modifiers.restrictSize({ min: { width: 120, height: 40 } })
            ]
        });

        window.addEventListener('DOMContentLoaded', function() {
          // Принудительно обновляем базовый макет (новый размер окна торговли и другие изменения)
          localStorage.setItem('monopoly_layout', JSON.stringify(BASE_LAYOUT));
        });

        window.addEventListener('DOMContentLoaded', function() {
          const btn = document.getElementById('end-turn-button');
          if (btn) {
            btn.setAttribute('data-x', 0);
            btn.setAttribute('data-y', 0);
            btn.style.transform = 'translate(0px, 0px)';
            btn.setAttribute('data-base-width', btn.offsetWidth);
            btn.setAttribute('data-base-height', btn.offsetHeight);
            btn.setAttribute('data-base-font', window.getComputedStyle(btn).fontSize);
            btn.onclick = nextPlayer;
          }
        });

        interact('#end-turn-button').draggable({
          listeners: {
            move(event) {
              const target = event.target;
              let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
              let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
              target.style.transform = `translate(${x}px, ${y}px)`;
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);
            }
          }
        });

        interact('#end-turn-button').resizable({
          edges: { top: true, left: true, bottom: true, right: true },
          listeners: {
            move(event) {
              const target = event.target;
              let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
              let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
              target.style.width = newWidth + 'px';
              target.style.height = newHeight + 'px';
              target.style.maxWidth = newWidth + 'px';
              target.style.maxHeight = newHeight + 'px';
              // Масштабируем текст кнопки пропорционально высоте (как у dice-button)
              const baseHeight = parseFloat(target.getAttribute('data-base-height')) || 48;
              const baseFont = parseFloat(target.getAttribute('data-base-font')) || 24;
              const scale = newHeight / baseHeight;
              target.style.fontSize = (baseFont * scale) + 'px';
            }
          },
          modifiers: [
            interact.modifiers.restrictSize({
              min: { width: 80, height: 32 },
              max: { width: 600, height: 200 }
            })
          ]
        });

        // ВАЖНО: Колоды техник и миссий создаются сразу с координатами (из макета или дефолтными).
        // Это гарантирует, что они появляются на нужном месте без "прыжка".
        // В applyLayoutData координаты deck-block и missions-deck-block НЕ меняются!
        // Если появится эффект "перелёта" — проверь порядок инициализации и этот паттерн.
        function placeDeckBlock() {
          let deck = document.getElementById('deck-block');
          let missionsDeck = document.getElementById('missions-deck-block');
          const board = document.getElementById('board');
          
          // Получаем макет (только для координат)
          let layout = JSON.parse(localStorage.getItem('monopoly_layout') || '{}');
          let deckLayout = layout.deckBlock;
          let missionsLayout = layout.missionsDeckBlock;

          // Для дефолтных координат — центр поля
          let rect = null, centerX = 0, centerY = 0;
          if (board) {
            rect = board.getBoundingClientRect();
            centerX = rect.left + rect.width/2;
            centerY = rect.top + rect.height/2;
          }
          
          // Создаём колоду техник
          if (!deck) {
            deck = document.createElement('div');
            deck.id = 'deck-block';
            deck.className = 'deck-block';
            deck.style.position = 'absolute';
            deck.style.width = (deckLayout && deckLayout.width ? deckLayout.width : 90) + 'px';
            deck.style.height = (deckLayout && deckLayout.height ? deckLayout.height : 120) + 'px';
            deck.style.zIndex = 3000;
            // --- Сразу задаём координаты ---
            let left1 = deckLayout && deckLayout.left ? parseFloat(deckLayout.left) : (centerX - 120);
            let top1 = deckLayout && deckLayout.top ? parseFloat(deckLayout.top) : (centerY - 60);
            deck.style.left = left1 + 'px';
            deck.style.top = top1 + 'px';
            deck.innerHTML = `
              <div class="deck-count">${techniquesDeck.count}</div>
              <div class="deck-stack">
                <div class="deck-card back"></div>
                <div class="deck-card back"></div>
                <div class="deck-card back"></div>
              </div>
              <div class="deck-label">Техники</div>
            `;
            document.body.appendChild(deck);
          }
          
          // Создаём колоду миссий
          if (!missionsDeck) {
            missionsDeck = document.createElement('div');
            missionsDeck.id = 'missions-deck-block';
            missionsDeck.className = 'deck-block missions';
            missionsDeck.style.position = 'absolute';
            missionsDeck.style.width = (missionsLayout && missionsLayout.width ? missionsLayout.width : 90) + 'px';
            missionsDeck.style.height = (missionsLayout && missionsLayout.height ? missionsLayout.height : 120) + 'px';
            missionsDeck.style.zIndex = 3000;
            // --- Сразу задаём координаты ---
            let left2 = missionsLayout && missionsLayout.left ? parseFloat(missionsLayout.left) : (centerX + 30);
            let top2 = missionsLayout && missionsLayout.top ? parseFloat(missionsLayout.top) : (centerY - 60);
            missionsDeck.style.left = left2 + 'px';
            missionsDeck.style.top = top2 + 'px';
            missionsDeck.innerHTML = `
              <div class="deck-count">12</div>
              <div class="deck-stack">
                <div class="deck-card back"></div>
                <div class="deck-card back"></div>
                <div class="deck-card back"></div>
              </div>
              <div class="deck-label">Миссии</div>
            `;
            document.body.appendChild(missionsDeck);
          }
        }
        window.addEventListener('DOMContentLoaded', function() {
            placeDeckBlock();
            // Небольшая задержка для гарантии создания колод
            setTimeout(setupDeckClickHandlers, 100);
        });
        window.addEventListener('resize', placeDeckBlock);

        // Drag & Resize для обеих колод + saveLayout
        window.addEventListener('DOMContentLoaded', function() {
          const deck = document.getElementById('deck-block');
          const missionsDeck = document.getElementById('missions-deck-block');
          
          // Настройка для колоды техник
          if (deck && window.interact) {
            // === УБРАНО: перезапись позиций, которая сбрасывала координаты из макета ===
            interact(deck).draggable({
              listeners: {
                move(event) {
                  const target = event.target;
                  let left = (parseFloat(target.style.left)||0) + event.dx;
                  let top = (parseFloat(target.style.top)||0) + event.dy;
                  target.style.left = left + 'px';
                  target.style.top = top + 'px';
                }
              }
            }).resizable({
              edges: { left: true, right: true, bottom: true, top: true },
              listeners: {
                move(event) {
                  const target = event.target;
                  let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
                  let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
                  target.style.width = newWidth + 'px';
                  target.style.height = newHeight + 'px';
                  let left = (parseFloat(target.style.left)||0) + event.deltaRect.left;
                  let top = (parseFloat(target.style.top)||0) + event.deltaRect.top;
                  target.style.left = left + 'px';
                  target.style.top = top + 'px';
                }
              },
              modifiers: [
                interact.modifiers.restrictSize({ min: { width: 60, height: 80 }, max: { width: 220, height: 320 } })
              ]
            });
          }
          
          // Настройка для колоды миссий
          if (missionsDeck && window.interact) {
            // === УБРАНО: перезапись позиций, которая сбрасывала координаты из макета ===
            interact(missionsDeck).draggable({
              listeners: {
                move(event) {
                  const target = event.target;
                  let left = (parseFloat(target.style.left)||0) + event.dx;
                  let top = (parseFloat(target.style.top)||0) + event.dy;
                  target.style.left = left + 'px';
                  target.style.top = top + 'px';
                }
              }
            }).resizable({
              edges: { left: true, right: true, bottom: true, top: true },
              listeners: {
                move(event) {
                  const target = event.target;
                  let newWidth = (parseFloat(target.style.width) || target.offsetWidth) + event.deltaRect.width;
                  let newHeight = (parseFloat(target.style.height) || target.offsetHeight) + event.deltaRect.height;
                  target.style.width = newWidth + 'px';
                  target.style.height = newHeight + 'px';
                  let left = (parseFloat(target.style.left)||0) + event.deltaRect.left;
                  let top = (parseFloat(target.style.top)||0) + event.deltaRect.top;
                  target.style.left = left + 'px';
                  target.style.top = top + 'px';
                }
              },
              modifiers: [
                interact.modifiers.restrictSize({ min: { width: 60, height: 80 }, max: { width: 220, height: 320 } })
              ]
            });
          }
        });

        // === Центр торговли с вкладками ===
        function renderTradeTab(tab) {
          const content = document.getElementById('trade-tab-content');
          // Сбросить активные вкладки
          document.querySelectorAll('.trade-tab-btn').forEach(btn => btn.classList.remove('active'));
          document.querySelector('.trade-tab-btn[data-tab="'+tab+'"]')?.classList.add('active');
          if (tab === 'exchange') {
            // --- Вкладка обмена ---
            content.innerHTML = `
              <div style='font-size:1.08em; margin-bottom:10px; color:#ffd700;'>Обмен между игроками</div>
              <div style="display:flex; gap:18px; justify-content:center; align-items:flex-start;">
                <div style="flex:1; min-width:140px;">
                  <div><b>Игрок 1:</b></div>
                  <div id="trade-player1-name" style="margin-bottom:2px;"></div>
                  <div style="margin-top:8px;">
                    <b>Имущество:</b>
                    <div id="trade-player1-assets" style="min-height:40px;"></div>
                  </div>
                  <div style="margin-top:8px;">
                    <b>Деньги:</b>
                    <input id="trade-player1-money" type="number" min="0" value="0" style="width:70px;"> рё
                  </div>
                </div>
                <div style="flex:1; min-width:140px;">
                  <div><b>Игрок 2:</b>
                    <select id="trade-player2"></select>
                  </div>
                  <div style="margin-top:8px;">
                    <b>Имущество:</b>
                    <div id="trade-player2-assets" style="min-height:40px;"></div>
                  </div>
                  <div style="margin-top:8px;">
                    <b>Деньги:</b>
                    <input id="trade-player2-money" type="number" min="0" value="0" style="width:70px;"> рё
                  </div>
                </div>
              </div>
              <div style="margin-top:18px; display:flex; gap:10px; justify-content:center;">
                <button class="modal-button" id="trade-propose-btn">Предложить обмен</button>
              </div>
            `;
            // --- JS для обмена ---
            const p1Name = document.getElementById('trade-player1-name');
            p1Name.textContent = players[currentPlayer].name;
            const p2Sel = document.getElementById('trade-player2');
            const assets1 = document.getElementById('trade-player1-assets');
            const assets2 = document.getElementById('trade-player2-assets');
            const money1 = document.getElementById('trade-player1-money');
            const money2 = document.getElementById('trade-player2-money');
            p2Sel.innerHTML = '';
            players.forEach((p, idx) => {
              if (idx !== currentPlayer) {
                const opt2 = document.createElement('option');
                opt2.value = idx; opt2.textContent = p.name;
                p2Sel.appendChild(opt2);
              }
            });
            let selected1 = { properties: [], techniques: [], missions: [] };
            let selected2 = { properties: [], techniques: [], missions: [] };
            function renderAssets(playerIdx, container, selectedAssets, onChange) {
              const p = players[playerIdx];
              container.innerHTML = '';
              const props = boardCells.filter(cell => cell.owner === playerIdx);
              if (props.length) {
                const label = document.createElement('div');
                label.textContent = 'Недвижимость:';
                label.style.fontWeight = 'bold';
                container.appendChild(label);
                props.forEach((cell, i) => {
                  const chk = document.createElement('input');
                  chk.type = 'checkbox';
                  chk.value = cell.name;
                  chk.checked = selectedAssets.properties && selectedAssets.properties.includes(cell.name);
                  chk.onchange = () => { onChange('properties', cell.name, chk.checked); };
                  container.appendChild(chk);
                  container.appendChild(document.createTextNode(' ' + cell.name));
                  container.appendChild(document.createElement('br'));
                });
              }
              if (p.techniques && p.techniques.length) {
                const label = document.createElement('div');
                label.textContent = 'Техники:';
                label.style.fontWeight = 'bold';
                container.appendChild(label);
                p.techniques.forEach((tech, i) => {
                  const chk = document.createElement('input');
                  chk.type = 'checkbox';
                  chk.value = tech.name;
                  chk.checked = selectedAssets.techniques && selectedAssets.techniques.includes(tech.name);
                  chk.onchange = () => { onChange('techniques', tech.name, chk.checked); };
                  container.appendChild(chk);
                  container.appendChild(document.createTextNode(' ' + tech.name));
                  container.appendChild(document.createElement('br'));
                });
              }
              if (p.missions && p.missions.length) {
                const label = document.createElement('div');
                label.textContent = 'Миссии:';
                label.style.fontWeight = 'bold';
                container.appendChild(label);
                p.missions.forEach((mis, i) => {
                  const chk = document.createElement('input');
                  chk.type = 'checkbox';
                  chk.value = mis.name;
                  chk.checked = selectedAssets.missions && selectedAssets.missions.includes(mis.name);
                  chk.onchange = () => { onChange('missions', mis.name, chk.checked); };
                  container.appendChild(chk);
                  container.appendChild(document.createTextNode(' ' + mis.name));
                  container.appendChild(document.createElement('br'));
                });
              }
            }
            function updateAssets() {
              renderAssets(currentPlayer, assets1, selected1, (type, name, checked) => {
                if (checked) selected1[type].push(name); else selected1[type] = selected1[type].filter(n => n !== name);
              });
              renderAssets(+p2Sel.value, assets2, selected2, (type, name, checked) => {
                if (checked) selected2[type].push(name); else selected2[type] = selected2[type].filter(n => n !== name);
              });
            }
            p2Sel.onchange = updateAssets;
            updateAssets();
            document.getElementById('trade-propose-btn').onclick = function() {
              // Здесь будет логика обмена
            };
          } else if (tab === 'market') {
            // --- Вкладка рынка ---
            content.innerHTML = `
              <div style='font-size:1.08em; margin-bottom:10px; color:#ffd700;'>Рынок</div>
              <div style='margin-bottom:10px;'><b>Курс валют</b> (чакра/монеты "рё")<br>1 чакра = 10 рё<br>1 техника = 200 рё (пример)</div>
              <div style='margin-bottom:10px;'><b>Популярные лоты</b><br>• Недвижимость: Учиха, Сенджу<br>• Техники: Расенган, Теневые клоны<br>• Миссии: Победить в дуэли</div>
              <div><b>Тренды цен</b><br>• Недвижимость дорожает<br>• Техники стабильны<br>• Миссии дешевеют</div>
            `;
          } else if (tab === 'auction') {
            // --- Вкладка аукциона ---
            content.innerHTML = `
              <div style='font-size:1.08em; margin-bottom:10px; color:#ffd700;'>Аукцион</div>
              <div>Пока аукцион не реализован. Здесь будут текущие торги, история цен и ставки игроков.</div>
            `;
          }
        }
        // Вкладки торговли — обработка кликов
        document.querySelectorAll('.trade-tab-btn').forEach(btn => {
          btn.onclick = function() {
            renderTradeTab(this.getAttribute('data-tab'));
          };
        });
        // По умолчанию — вкладка обмена
        renderTradeTab('exchange');

        // === Глобальные переменные для колод ===
        // В колоду техник попадают только обычные техники (temporary, instant), финальные и клановые не включаются
        let techniquesDeck = {
            cards: (typeof techniques !== 'undefined') ? techniques.filter(t => t.type === 'temporary' || t.type === 'instant').map(t => ({...t})) : [],
            get count() { return this.cards.length; }
        };
        
        let missionsDeck = {
            count: 12,
            cards: [
                {name: "Победить в дуэли", icon: "⚔️", description: "Победить любого игрока в бою", reward: "200 рё + 50 чакры"},
                {name: "Владеть кланом", icon: "🏯", description: "Приобрести все клетки одного клана", reward: "300 рё"},
                {name: "Собрать техники", icon: "💥", description: "Иметь 5 техник одновременно", reward: "150 рё + 30 чакры"},
                {name: "Богатство", icon: "💰", description: "Накопить 3000 рё", reward: "500 рё"},
                {name: "Чакра-мастер", icon: "🔵", description: "Достичь 200 чакры", reward: "100 рё + 100 чакры"},
                {name: "Путешественник", icon: "🗺️", description: "Побывать на всех углах поля", reward: "250 рё"},
                {name: "Торговец", icon: "🤝", description: "Провести 3 обмена", reward: "180 рё"},
                {name: "Счастливчик", icon: "🍀", description: "Выбросить 3 дубля подряд", reward: "400 рё"},
                {name: "Выживший", icon: "🛡️", description: "Пройти 20 ходов без потери чакры", reward: "350 рё"},
                {name: "Коллекционер", icon: "📦", description: "Владеть 10 клетками", reward: "280 рё"},
                {name: "Мастер дзюцу", icon: "🥋", description: "Активировать 10 техник", reward: "320 рё + 80 чакры"},
                {name: "Победитель", icon: "🏆", description: "Победить в 5 дуэлях", reward: "600 рё"}
            ]
        };

        // === Функции для работы с колодами ===
        function drawCard(deckType) {
            const deckElement = deckType === 'techniques' ? document.getElementById('deck-block') : document.getElementById('missions-deck-block');
            if (deckType === 'techniques') {
                if (techniquesDeck.count <= 0) {
                    showMessage('Колода техник пуста!');
                    return null;
                }
                // Анимация вытягивания карты
                animateCardDraw(deckElement, () => {
                    const randomIndex = Math.floor(Math.random() * techniquesDeck.cards.length);
                    const card = techniquesDeck.cards.splice(randomIndex, 1)[0];
                    techniquesDeck.count = techniquesDeck.cards.length;
                    updateDeckCount('deck-block', techniquesDeck.count);
                    showCardModal(card, 'technique', () => {
                        // Добавляем технику текущему игроку
                        if (typeof players !== 'undefined' && typeof currentPlayer !== 'undefined') {
                            players[currentPlayer].techniques.push({...card});
                            // Всегда обновляем персональное окно для выбранного игрока
                            if (typeof renderPlayerPanel === 'function' && window.selectedPlayer) {
                                renderPlayerPanel(window.selectedPlayer);
                            }
                        }
                    });
                    return card;
                });
                return;
            } else if (deckType === 'missions') {
                if (missionsDeck.count <= 0) {
                    showMessage('Колода миссий пуста!');
                    return null;
                }
                
                // Анимация вытягивания карты
                animateCardDraw(deckElement, () => {
                    const randomIndex = Math.floor(Math.random() * missionsDeck.cards.length);
                    const card = missionsDeck.cards[randomIndex];
                    missionsDeck.count--;
                    updateDeckCount('missions-deck-block', missionsDeck.count);
                    showCardModal(card, 'mission');
                    return card;
                });
            }
        }

        function animateCardDraw(deckElement, callback) {
            // Создаём анимированную карту
            const animatedCard = document.createElement('div');
            animatedCard.style.position = 'absolute';
            animatedCard.style.width = '60px';
            animatedCard.style.height = '80px';
            animatedCard.style.background = 'linear-gradient(135deg, #fff 0%, #f0f0f0 50%, #fff 100%)';
            animatedCard.style.border = '2px solid #ddd';
            animatedCard.style.borderRadius = '10px';
            animatedCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
            animatedCard.style.zIndex = '4000';
            animatedCard.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            
            // Позиционируем карту поверх колоды
            const deckRect = deckElement.getBoundingClientRect();
            animatedCard.style.left = (deckRect.left + deckRect.width/2 - 30) + 'px';
            animatedCard.style.top = (deckRect.top + deckRect.height/2 - 40) + 'px';
            
            document.body.appendChild(animatedCard);
            
            // Анимация вытягивания
            setTimeout(() => {
                animatedCard.style.transform = 'translateY(-100px) scale(1.2) rotate(5deg)';
                animatedCard.style.opacity = '0.8';
            }, 50);
            
            setTimeout(() => {
                animatedCard.remove();
                callback();
            }, 600);
        }

        function updateDeckCount(deckId, count) {
            const deck = document.getElementById(deckId);
            if (deck) {
                const countElement = deck.querySelector('.deck-count');
                if (countElement) {
                    countElement.textContent = count;
                    // Анимация изменения счётчика
                    countElement.style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        countElement.style.transform = 'scale(1)';
                    }, 200);
                }
            }
        }

        function showCardModal(card, type, onReceive) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '3000';
            const cardColor = type === 'technique' ? '#ffd700' : '#4fc3f7';
            const cardBg = type === 'technique' ? 'linear-gradient(135deg, #ffd700 0%, #fffbe0 50%, #ffd700 100%)' : 'linear-gradient(135deg, #4fc3f7 0%, #e1f5fe 50%, #4fc3f7 100%)';
            modal.innerHTML = `
                <div class="modal-content" style="background: ${cardBg}; color: #23243a; border: 3px solid ${cardColor}; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 3em; margin-bottom: 10px;">${card.icon}</div>
                        <h2 style="color: #23243a; margin: 0;">${card.name}</h2>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <p style="margin: 5px 0; font-weight: 600;">${card.description}</p>
                        <p style="margin: 5px 0; color: ${type === 'technique' ? '#d32f2f' : '#1976d2'}; font-weight: bold;">
                            ${type === 'technique' ? 'Эффект:' : 'Награда:'} ${type === 'technique' ? card.effect || card.description : card.reward}
                        </p>
                    </div>
                    <button class="modal-button" onclick="closeCardModal(this, ${!!onReceive})" style="background: ${cardColor}; color: #23243a; font-weight: bold;">Получить карту</button>
                </div>
            `;
            document.body.appendChild(modal);
            // Анимация появления карты
            const content = modal.querySelector('.modal-content');
            content.style.transform = 'scale(0.5)';
            content.style.opacity = '0';
            setTimeout(() => {
                content.style.transition = 'all 0.3s ease';
                content.style.transform = 'scale(1)';
                content.style.opacity = '1';
            }, 10);
            // Сохраняем коллбек для вызова после получения
            if (onReceive) modal._onReceive = onReceive;
        }
        function closeCardModal(button, callReceive) {
            const modal = button.closest('.modal');
            const content = modal.querySelector('.modal-content');
            content.style.transition = 'all 0.3s ease';
            content.style.transform = 'scale(0.5)';
            content.style.opacity = '0';
            setTimeout(() => {
                if (callReceive && typeof modal._onReceive === 'function') modal._onReceive();
                modal.remove();
            }, 300);
        }

        // === Обработчики кликов по колодам ===
        function setupDeckClickHandlers() {
            const techniquesDeck = document.getElementById('deck-block');
            const missionsDeck = document.getElementById('missions-deck-block');
            
            if (techniquesDeck) {
                techniquesDeck.style.cursor = 'pointer';
                techniquesDeck.onclick = function(e) {
                    // Не срабатывает при resize
                    if (e.target.classList.contains('deck-count') || e.target.classList.contains('deck-label')) {
                        return;
                    }
                    drawCard('techniques');
                };
            }
            
            if (missionsDeck) {
                missionsDeck.style.cursor = 'pointer';
                missionsDeck.onclick = function(e) {
                    // Не срабатывает при resize
                    if (e.target.classList.contains('deck-count') || e.target.classList.contains('deck-label')) {
                        return;
                    }
                    drawCard('missions');
                };
            }
        }

        // --- Функция позиционирования окна статистики ---
        function positionStatsWindowBetweenEdgeAndBoard() {
          const stats = document.getElementById('stats-window');
          const board = document.getElementById('board');
          if (!stats || !board) return;
          // Принудительно делаем окно видимым для расчёта ширины, если оно скрыто
          const wasHidden = stats.style.display === 'none' || window.getComputedStyle(stats).display === 'none';
          if (wasHidden) {
            stats.style.visibility = 'hidden';
            stats.style.display = 'block';
          }
          const boardRect = board.getBoundingClientRect();
          const statsWidth = stats.offsetWidth;
          const left = Math.round(boardRect.left / 2 - statsWidth / 2);
          stats.style.left = left + 'px';
          stats.style.top = '80px';
          stats.setAttribute('data-x', left);
          stats.setAttribute('data-y', 80);
          if (wasHidden) {
            stats.style.display = 'none';
            stats.style.visibility = '';
          }
        }
        window.addEventListener('resize', positionStatsWindowBetweenEdgeAndBoard);
        // После применения макета (только один блок, без дублей)
        var origApplyLayoutData = applyLayoutData;
        applyLayoutData = function(layout) {
          origApplyLayoutData(layout);
          // Trade window: восстанавливаем всё из макета
          const trade = document.getElementById('trade-window');
          if (trade && layout.tradeWindow) {
            trade.style.left = layout.tradeWindow.x + 'px';
            trade.style.top = layout.tradeWindow.y + 'px';
            trade.style.width = layout.tradeWindow.width + 'px';
            trade.style.height = layout.tradeWindow.height + 'px';
            trade.style.display = layout.tradeWindow.visible ? 'block' : 'none';
            trade.setAttribute('data-x', layout.tradeWindow.x);
            trade.setAttribute('data-y', layout.tradeWindow.y);
          }
          // Stats window: только размеры и display, координаты НЕ трогаем!
          const stats = document.getElementById('stats-window');
          if (stats && layout.statsWindow) {
            stats.style.width = layout.statsWindow.width + 'px';
            stats.style.height = layout.statsWindow.height + 'px';
            stats.style.display = layout.statsWindow.visible ? 'block' : 'none';
          }
          // После восстановления макета — позиционируем stats-window по формуле
          positionStatsWindowBetweenEdgeAndBoard();
        };
        // При открытии stats-window
        const origShowWindow = window.showWindow;
        window.showWindow = function(id) {
          origShowWindow(id);
          if (id === 'stats-window') {
            positionStatsWindowBetweenEdgeAndBoard();
          }
        };
        const origToggleWindow = window.toggleWindow;
        window.toggleWindow = function(id) {
          origToggleWindow(id);
          if (id === 'stats-window') {
            positionStatsWindowBetweenEdgeAndBoard();
          }
        };

        // --- Функция позиционирования окна торговли слева от board ---
        function positionTradeWindowLeftOfBoard() {
          const trade = document.getElementById('trade-window');
          const board = document.getElementById('board');
          if (!trade || !board) return;
          // Принудительно делаем окно видимым для расчёта ширины, если оно скрыто
          const wasHidden = trade.style.display === 'none' || window.getComputedStyle(trade).display === 'none';
          if (wasHidden) {
            trade.style.visibility = 'hidden';
            trade.style.display = 'block';
          }
          const boardRect = board.getBoundingClientRect();
          const tradeWidth = trade.offsetWidth;
          // Левый край окна торговли = левый край board - tradeWidth - 12px
          const left = Math.round(boardRect.left - tradeWidth - 12);
          // По вертикали — как help-window и stats-window (top: 80px)
          trade.style.left = left + 'px';
          trade.style.top = '80px';
          trade.setAttribute('data-x', left);
          trade.setAttribute('data-y', 80);
          if (wasHidden) {
            trade.style.display = 'none';
            trade.style.visibility = '';
          }
        }
        window.addEventListener('resize', positionTradeWindowLeftOfBoard);
        // После применения макета — позиционируем trade-window по формуле
        var origApplyLayoutData2 = applyLayoutData;
        applyLayoutData = function(layout) {
          origApplyLayoutData2(layout);
          // Trade window: позиционируем по формуле
          positionTradeWindowLeftOfBoard();
        };
        // При открытии trade-window
        const origShowWindow2 = window.showWindow;
        window.showWindow = function(id) {
          origShowWindow2(id);
          if (id === 'trade-window') {
            positionTradeWindowLeftOfBoard();
          }
        };
        const origToggleWindow2 = window.toggleWindow;
        window.toggleWindow = function(id) {
          origToggleWindow2(id);
          if (id === 'trade-window') {
            positionTradeWindowLeftOfBoard();
          }
        };
    </script>
    <script>
(function(){
  // --- Модальные окна (создаются один раз) ---
  function ensureModals() {
    if (!document.getElementById('tech-modal-bg')) {
      const techModal = document.createElement('div');
      techModal.id = 'tech-modal-bg';
      techModal.style = 'display:none; position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(30,32,40,0.7); align-items:center; justify-content:center;';
      techModal.innerHTML = `<div id="tech-modal" style="background:#23243a; color:#fff; border-radius:14px; box-shadow:0 4px 24px #0008; padding:32px 28px; min-width:320px; max-width:90vw; position:relative;">
        <button class="close" style="position:absolute; top:10px; right:18px; font-size:1.5rem; color:#fff; background:none; border:none; cursor:pointer; opacity:0.7;" onclick="document.getElementById('tech-modal-bg').style.display='none'">×</button>
        <h2 style='margin-bottom:18px;'>Техники</h2>
        <div id="tech-modal-content"></div>
      </div>`;
      document.body.appendChild(techModal);
    }
    if (!document.getElementById('mission-modal-bg')) {
      const missionModal = document.createElement('div');
      missionModal.id = 'mission-modal-bg';
      missionModal.style = 'display:none; position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(30,32,40,0.7); align-items:center; justify-content:center;';
      missionModal.innerHTML = `<div id="mission-modal" style="background:#23243a; color:#fff; border-radius:14px; box-shadow:0 4px 24px #0008; padding:32px 28px; min-width:320px; max-width:90vw; position:relative;">
        <button class="close" style="position:absolute; top:10px; right:18px; font-size:1.5rem; color:#fff; background:none; border:none; cursor:pointer; opacity:0.7;" onclick="document.getElementById('mission-modal-bg').style.display='none'">×</button>
        <h2 style='margin-bottom:18px;'>Миссии</h2>
        <div id="mission-modal-content"></div>
      </div>`;
      document.body.appendChild(missionModal);
    }
  }
  // --- Открытие модалок ---
  function openTechModal(player) {
    ensureModals();
    const modal = document.getElementById('tech-modal-bg');
    const content = document.getElementById('tech-modal-content');
    content.innerHTML = '';
    if (!player.pinnedTechniques) player.pinnedTechniques = [];
    // --- Группировка техник ---
    const ordinary = (player.techniques||[]).filter(t => !t.type || t.type === 'temporary' || t.type === 'instant' || t.type === 'passive');
    const clanFinal = (player.techniques||[]).filter(t => t.type === 'clan');
    const universalFinal = (player.techniques||[]).filter(t => t.type === 'universal');
    function renderTechRow(tech, player, idx) {
        const el = document.createElement('div');
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.gap = '8px';
        el.style.background = tech.type === 'passive' ? '#2e7d32' : tech.type === 'clan' ? '#ffd54f' : tech.type === 'universal' ? '#6a1b9a' : (tech.canActivate ? '#263b5e' : '#44485a');
        el.style.color = tech.type === 'passive' ? '#b9f6ca' : tech.type === 'clan' ? '#23243a' : tech.type === 'universal' ? '#ffd54f' : (tech.canActivate ? '#7ecbff' : '#bbb');
        el.style.fontWeight = '700';
        el.style.borderRadius = '8px';
        el.style.padding = '6px 14px 6px 10px';
        el.style.marginBottom = '10px';
        el.style.boxShadow = tech.type === 'passive' ? '0 1px 4px #2e7d32' : tech.type === 'clan' ? '0 1px 4px #ffd54f' : tech.type === 'universal' ? '0 1px 4px #6a1b9a' : '0 1px 4px #0003';
        el.innerHTML = `<span style=\"font-size:22px;\">${tech.icon||'🌀'}</span><span style=\"font-size:1.1em;\">${tech.name}</span>`;
        if (tech.description) {
          const desc = document.createElement('span');
          desc.textContent = tech.description;
          desc.style.fontSize = '0.98em';
          desc.style.opacity = '0.8';
          desc.style.marginLeft = '10px';
          el.appendChild(desc);
        }
        // Кнопки справа (flex-row, строго справа)
        const btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        btnRow.style.marginLeft = 'auto';
        // Кнопка "Активировать" только для обычных техник
        if (!tech.type || tech.type === 'temporary' || tech.type === 'instant') {
          const activateBtn = document.createElement('button');
          activateBtn.textContent = 'Активировать';
          activateBtn.disabled = false;
          activateBtn.style.fontSize = '13px';
          activateBtn.style.background = '#7ecbff';
          activateBtn.style.color = '#23243a';
          activateBtn.style.fontWeight = '700';
          activateBtn.style.border = 'none';
          activateBtn.style.borderRadius = '6px';
          activateBtn.style.cursor = 'pointer';
          activateBtn.style.padding = '4px 14px';
          activateBtn.onclick = function(e) {
            e.stopPropagation();
            if (typeof activateTechnique === 'function') activateTechnique(tech);
            else showMessage(`Техника '${tech.name}' активирована!`);
          };
          btnRow.appendChild(activateBtn);
        }
        // Кнопка закрепления (если не дефолтная)
        const isDefault = (player && player.name && charAbilities && charAbilities[player.name] && charAbilities[player.name].name === tech.name);
        if (!isDefault) {
          const isPinned = player.pinnedTechniques.includes(tech.name);
          const pinBtn = document.createElement('button');
          pinBtn.textContent = isPinned ? 'Убрать из панели' : 'Закрепить в панели';
          pinBtn.style.fontSize = '13px';
          pinBtn.style.background = isPinned ? '#bbb' : '#ffd54f';
          pinBtn.style.color = '#23243a';
          pinBtn.style.fontWeight = '700';
          pinBtn.style.border = 'none';
          pinBtn.style.borderRadius = '6px';
          pinBtn.style.cursor = 'pointer';
          pinBtn.style.padding = '4px 14px';
          pinBtn.onmouseover = () => pinBtn.style.background = isPinned ? '#ccc' : '#ffe082';
          pinBtn.onmouseout = () => pinBtn.style.background = isPinned ? '#bbb' : '#ffd54f';
          pinBtn.onclick = () => {
            if (isPinned) {
              player.pinnedTechniques = player.pinnedTechniques.filter(n => n !== tech.name);
              openTechModal(player);
              if (window.renderPlayerPanel && window.selectedPlayer) window.renderPlayerPanel(window.selectedPlayer);
            } else {
              // Запрещаем закреплять дефолтную технику
              if (isDefault) return;
              const currentOrdinary = player.pinnedTechniques.filter(name => {
                const tech = player.techniques.find(t => t.name === name);
              return tech && tech.type !== 'universal' && tech.type !== 'clan';
              }).length;
            const currentFinal = player.pinnedTechniques.filter(name => {
                const tech = player.techniques.find(t => t.name === name);
              return tech && (tech.type === 'universal' || tech.type === 'clan');
              }).length;
            if ((tech.type === 'universal' || tech.type === 'clan') && currentFinal >= 1) {
                alert('Можно закрепить не более 1 финальной техники!');
                return;
              }
            if ((!tech.type || tech.type === 'temporary' || tech.type === 'instant' || tech.type === 'passive') && currentOrdinary >= 3) {
                alert('Можно закрепить не более 3 обычных техник!');
                return;
              }
              player.pinnedTechniques.push(tech.name);
              openTechModal(player);
              if (window.renderPlayerPanel && window.selectedPlayer) window.renderPlayerPanel(window.selectedPlayer);
            }
          };
          btnRow.appendChild(pinBtn);
        }
        el.appendChild(btnRow);
        return el;
    }
    // --- Обычные ---
    const hOrd = document.createElement('div');
    hOrd.textContent = `Обычные техники (${ordinary.length}/3)`;
    hOrd.style = 'font-weight:700; color:#7ecbff; margin:10px 0 4px 0; font-size:1.08em;';
    content.appendChild(hOrd);
    ordinary.forEach((tech, idx) => content.appendChild(renderTechRow(tech, player, idx)));
    // --- Клановые финальные ---
    const hClan = document.createElement('div');
    hClan.textContent = `Клановые финальные техники (${clanFinal.length}/1)`;
    hClan.style = 'font-weight:700; color:#ffd54f; margin:10px 0 4px 0; font-size:1.08em;';
    content.appendChild(hClan);
    clanFinal.forEach((tech, idx) => content.appendChild(renderTechRow(tech, player, idx)));
    // --- Универсальные финальные ---
    const hUniv = document.createElement('div');
    hUniv.textContent = `Универсальные финальные техники (${universalFinal.length}/1)`;
    hUniv.style = 'font-weight:700; color:#b39ddb; margin:10px 0 4px 0; font-size:1.08em;';
    content.appendChild(hUniv);
    universalFinal.forEach((tech, idx) => content.appendChild(renderTechRow(tech, player, idx)));
    modal.style.display = 'flex';
  }
  function openMissionModal(player) {
    ensureModals();
    const modal = document.getElementById('mission-modal-bg');
    const content = document.getElementById('mission-modal-content');
    content.innerHTML = '';
    if (player && player.missions && player.missions.length) {
      player.missions.forEach(mis => {
        const el = document.createElement('div');
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.gap = '8px';
        el.style.background = '#ffd54f';
        el.style.color = '#23243a';
        el.style.fontWeight = '700';
        el.style.borderRadius = '8px';
        el.style.padding = '6px 14px 6px 10px';
        el.style.marginBottom = '10px';
        el.style.boxShadow = '0 1px 4px #ffd54f33';
        el.innerHTML = `<span style="font-size:22px;">${mis.icon||'🎯'}</span><span style="font-size:1.1em;">${mis.name}</span>`;
        if (mis.description) {
          const desc = document.createElement('span');
          desc.textContent = mis.description;
          desc.style.fontSize = '0.98em';
          desc.style.opacity = '0.8';
          desc.style.marginLeft = '10px';
          el.appendChild(desc);
        }
        content.appendChild(el);
      });
    } else {
      content.innerHTML = '<div style="opacity:0.7;">Нет миссий</div>';
    }
    modal.style.display = 'flex';
  }
  // --- Навешиваем обработчики ---
        window.addEventListener('DOMContentLoaded', function() {
    ensureModals();
    var techBtn = document.getElementById('open-tech-modal-btn');
    var missionBtn = document.getElementById('open-mission-modal-btn');
    if (techBtn) techBtn.onclick = function() {
      // Берём текущего игрока из renderPlayerPanel, если есть
      var player = window.currentPlayerObj || window.lastRenderedPlayer || (typeof players !== 'undefined' ? players[currentPlayer] : null);
      openTechModal(player);
    };
    if (missionBtn) missionBtn.onclick = function() {
      var player = window.currentPlayerObj || window.lastRenderedPlayer || (typeof players !== 'undefined' ? players[currentPlayer] : null);
      openMissionModal(player);
    };
  });
})();
    </script>
    <script>
(function(){
  function switchPlayerTab(tab) {
    document.querySelectorAll('#player-panel-body .player-tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('#player-panel-body .player-tab-content').forEach(c => c.style.display = 'none');
    document.querySelector('#player-panel-body .player-tab-btn[data-tab="'+tab+'"]')?.classList.add('active');
    document.getElementById('player-tab-'+tab).style.display = '';
  }
  document.querySelectorAll('#player-panel-body .player-tab-btn').forEach(btn => {
    btn.onclick = function() { switchPlayerTab(btn.dataset.tab); };
  });
  switchPlayerTab('main');
})();
</script>
<script>
// Гарантированно создаём ability-tooltip при загрузке страницы
        window.addEventListener('DOMContentLoaded', function() {
  if (!document.getElementById('ability-tooltip')) {
    const tooltip = document.createElement('div');
    tooltip.id = 'ability-tooltip';
    tooltip.style = 'display:none; position:fixed; z-index:99999; min-width:220px; max-width:340px; background:#23243a; color:#ffd54f; border-radius:12px; box-shadow:0 4px 24px #000a; padding:18px 18px 14px 18px; font-size:1.08em; line-height:1.4;';
    tooltip.innerHTML = '<div id="ability-tooltip-content"></div>';
    document.body.appendChild(tooltip);
  }
});
    </script>
    <script>
        // ... существующий код ...
        // Удаляем drag&drop для help-window, если был
        window.addEventListener('DOMContentLoaded', function() {
          const helpWin = document.getElementById('help-window');
          if (helpWin && typeof interact === 'function') {
            try { interact('#help-window').unset(); } catch(e){}
          }
        });
        // ... существующий код ...
        window.addEventListener('DOMContentLoaded', function() {
          // После применения макета и рендера кнопок
          setTimeout(function() {
            const diceBtn = document.getElementById('dice-button');
            const endTurnBtn = document.getElementById('end-turn-button');
            if (diceBtn && endTurnBtn) {
              // Получаем абсолютные координаты центров
              const diceRect = diceBtn.getBoundingClientRect();
              const endTurnRect = endTurnBtn.getBoundingClientRect();
              // Разница между центрами по горизонтали
              const delta = (diceRect.left + diceRect.width / 2) - (endTurnRect.left + endTurnRect.width / 2);
              // Текущий left для endTurnBtn (относительно offsetParent)
              const currentLeft = parseFloat(window.getComputedStyle(endTurnBtn).left);
              // Корректируем left на разницу
              endTurnBtn.style.left = (currentLeft + delta) + 'px';
            }
          }, 0);
        });
        // ... существующий код ...
</script>
</body>
</html> 