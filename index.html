<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Fish Game Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #b3e6ff;
    }
    canvas {
      display: block;
      margin: 0;
      padding: 0;
      background: #b3e6ff;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    // Пути к ассетам
    const assets = {
      sand: 'fishpack2/PNG/Default/terrain_sand_a.png',
      sand_top: 'fishpack2/PNG/Default/terrain_sand_top_a.png',
      rock_a: 'fishpack2/PNG/Default/rock_a.png',
      rock_b: 'fishpack2/PNG/Default/rock_b.png',
      rock_a_outline: 'fishpack2/PNG/Default/rock_a_outline.png',
      rock_b_outline: 'fishpack2/PNG/Default/rock_b_outline.png',
      seaweed_green_a: 'fishpack2/PNG/Default/seaweed_green_a.png',
      seaweed_green_b: 'fishpack2/PNG/Default/seaweed_green_b.png',
      seaweed_green_c: 'fishpack2/PNG/Default/seaweed_green_c.png',
      seaweed_green_d: 'fishpack2/PNG/Default/seaweed_green_d.png',
      seaweed_green_a_outline: 'fishpack2/PNG/Default/seaweed_green_a_outline.png',
      seaweed_green_b_outline: 'fishpack2/PNG/Default/seaweed_green_b_outline.png',
      seaweed_pink_a: 'fishpack2/PNG/Default/seaweed_pink_a.png',
      seaweed_pink_b: 'fishpack2/PNG/Default/seaweed_pink_b.png',
      seaweed_pink_c: 'fishpack2/PNG/Default/seaweed_pink_c.png',
      seaweed_pink_d: 'fishpack2/PNG/Default/seaweed_pink_d.png',
      seaweed_pink_a_outline: 'fishpack2/PNG/Default/seaweed_pink_a_outline.png',
      seaweed_pink_b_outline: 'fishpack2/PNG/Default/seaweed_pink_b_outline.png',
      seaweed_pink_c_outline: 'fishpack2/PNG/Default/seaweed_pink_c_outline.png',
      seaweed_pink_d_outline: 'fishpack2/PNG/Default/seaweed_pink_d_outline.png',
      seaweed_orange_a: 'fishpack2/PNG/Default/seaweed_orange_a.png',
      seaweed_orange_b: 'fishpack2/PNG/Default/seaweed_orange_b.png',
      seaweed_orange_a_outline: 'fishpack2/PNG/Default/seaweed_orange_a_outline.png',
      seaweed_orange_b_outline: 'fishpack2/PNG/Default/seaweed_orange_b_outline.png',
      seaweed_grass_a: 'fishpack2/PNG/Default/seaweed_grass_a.png',
      seaweed_grass_b: 'fishpack2/PNG/Default/seaweed_grass_b.png',
      seaweed_grass_a_outline: 'fishpack2/PNG/Default/seaweed_grass_a_outline.png',
      seaweed_grass_b_outline: 'fishpack2/PNG/Default/seaweed_grass_b_outline.png',
      shell: 'fishpack2/PNG/Default/seaweed_pink_c.png', // временно как ракушка
      fish_red: 'fishpack2/PNG/Default/fish_red.png',
      fish_orange: 'fishpack2/PNG/Default/fish_orange.png',
      fish_pink: 'fishpack2/PNG/Default/fish_pink.png',
      fish_grey: 'fishpack2/PNG/Default/fish_grey.png',
      fish_skeleton: 'fishpack2/PNG/Default/fish_red_skeleton.png',
      bubble: 'fishpack2/PNG/Default/hud_dot.png',
      hud_2: 'fishpack2/PNG/Default/hud_number_2.png',
      hud_dot: 'fishpack2/PNG/Default/hud_dot.png',
      hud_0: 'fishpack2/PNG/Default/hud_number_0.png',
      fish_grey_outline: 'fishpack2/PNG/Default/fish_grey_outline.png',
    };
    // --- Список seaweed-ассетов для точного определения растений ---
    const SEAWEED_ASSETS = new Set([
      'seaweed_green_a', 'seaweed_green_b', 'seaweed_green_c', 'seaweed_green_d',
      'seaweed_green_a_outline', 'seaweed_green_b_outline',
      'seaweed_pink_a', 'seaweed_pink_b', 'seaweed_pink_c', 'seaweed_pink_d',
      'seaweed_pink_a_outline', 'seaweed_pink_b_outline', 'seaweed_pink_c_outline', 'seaweed_pink_d_outline',
      'seaweed_orange_a', 'seaweed_orange_b', 'seaweed_orange_a_outline', 'seaweed_orange_b_outline',
      'seaweed_grass_a', 'seaweed_grass_b', 'seaweed_grass_a_outline', 'seaweed_grass_b_outline'
    ]);

    // === Mikasa (висит сверху) ===
    const mikasaImg = new Image();
    mikasaImg.src = 'fishpack2/PNG/mikasa.png'; // Поместите файл mikasa.png в эту папку

    // Соотношение сторон исходной игры
    let canvas = document.getElementById('game');
    let ctx = canvas.getContext('2d');
    let mikasaLoaded = false;
    mikasaImg.onload = () => { mikasaLoaded = true; };
    mikasaImg.onerror = () => { mikasaLoaded = false; };

    function resizeCanvas() {
      let w = window.innerWidth;
      let h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    resizeCanvas();

    // Массив рыб для анимации
    const fishTypes = [
      {img: 'fish_red', count: 5},
      {img: 'fish_orange', count: 5},
      {img: 'fish_pink', count: 5},
      {img: 'fish_grey', count: 2},
      {img: 'fish_grey_outline', count: 1},
      {img: 'fish_skeleton', count: 4},
      {img: 'fish_gold', count: 0, rare: true} // редкая рыба, не создаём по умолчанию
    ];

    // Автоматическая генерация элементов дна с промежутками, слоями и композицией
    function generateBottomElements(img) {
      // Жёсткая фильтрация ассетов: исключаем все terrain_sand_*
      let groundAssets = [
      'rock_a', 'rock_b', 'rock_a_outline', 'rock_b_outline',
      'seaweed_green_a', 'seaweed_green_b', 'seaweed_green_c', 'seaweed_green_d',
      'seaweed_green_a_outline', 'seaweed_green_b_outline',
      'seaweed_pink_a', 'seaweed_pink_b', 'seaweed_pink_c', 'seaweed_pink_d',
      'seaweed_pink_a_outline', 'seaweed_pink_b_outline', 'seaweed_pink_c_outline', 'seaweed_pink_d_outline',
      'seaweed_orange_a', 'seaweed_orange_b', 'seaweed_orange_a_outline', 'seaweed_orange_b_outline',
      'seaweed_grass_a', 'seaweed_grass_b', 'seaweed_grass_a_outline', 'seaweed_grass_b_outline',
        'shell'
      ];
      groundAssets = groundAssets.filter(name => !/^terrain_sand_/.test(name));
      // 1. Количество декораций: 15-25
      const decorCount = Math.floor(15 + Math.random() * 11); // 15–25
      // 2. Перемешать ассеты и выбрать разнообразные
      const shuffled = groundAssets.slice().sort(() => Math.random() - 0.5);
      // Если ассетов меньше, чем нужно, разрешаем повторы, но не подряд
      let selected = [];
      let idx = 0;
      while (selected.length < decorCount) {
        let asset = shuffled[idx % shuffled.length];
        // Не допускать подряд одинаковых ассетов
        if (selected.length === 0 || selected[selected.length - 1] !== asset) {
          selected.push(asset);
        } else {
          // Если подряд — взять следующий
          idx++;
          continue;
        }
        idx++;
      }
      // 3. Разбить дно на сектора
      const sandTopY = Math.floor(canvas.height * 0.8);
      const sandBottomY = canvas.height;
      const marginY = 18;
      const sectorWidth = canvas.width / decorCount;
    const bottomElements = [];
      for (let i = 0; i < decorCount; i++) {
        const asset = selected[i];
        const scale = 0.8 + Math.random() * 1.2;
        const imgHeight = img && img[asset] ? img[asset].height : 40;
        const elemHeight = imgHeight * scale;
        // Центр сектора + случайное смещение
        const baseX = sectorWidth * (i + 0.5);
        const offsetX = (Math.random() - 0.5) * sectorWidth * 0.6;
        const x = baseX + offsetX;
        // Y — равномерно по всей высоте песчаного дна
        const yMin = sandTopY - elemHeight * 0.2; // чуть выше песка, чтобы не обрезались
        const yMax = sandBottomY - elemHeight - 4;
        const y = yMin + Math.random() * Math.max(0, yMax - yMin);
        const angle = (Math.random() - 0.5) * 0.3;
        bottomElements.push({
          img: asset, x, y, scale, alpha: 0.9, angle
        });
      }
      // После формирования bottomElements — логируем ассеты для контроля
      console.log('Bottom elements:', bottomElements.map(e => e.img));
      return bottomElements;
    }
    let bottomElements = [];

    function loadImages(assetList, callback) {
      const images = {};
      let loaded = 0, total = Object.keys(assetList).length;
      for (let key in assetList) {
        images[key] = new Image();
        images[key].src = assetList[key];
        images[key].onload = () => {
          loaded++;
          if (loaded === total) callback(images);
        };
      }
    }

    // Генерация рыб с пузырьками
    function generateFish(images) {
      const fishArr = [];
      fishTypes.forEach(type => {
        for (let i = 0; i < type.count; i++) {
          // --- Редкая рыба ---
          let isRare = false;
          let fishImg = images[type.img];
          if (!type.rare && Math.random() < 1/20) { // 1 из 20 шанс
            isRare = true;
            fishImg = images['fish_orange']; // используем обычную рыбу, перекрасим ниже
          }
          fishArr.push({
            img: fishImg,
            x: Math.random() * (canvas.width - 180) + 90,
            y: Math.random() * (canvas.height - 180) + 60,
            speed: Math.random() * 1.5 + 0.5 + (isRare ? 0.5 : 0),
            dir: Math.random() > 0.5 ? 1 : -1,
            size: (Math.random() * 0.5 + 0.7) * (isRare ? 1.18 : 1),
            baseSize: 0,
            feedCount: 0,
            ageTimer: 0,
            bubbleTimer: Math.random() * 80 + 40,
            bubbles: [],
            waveOffset: Math.random() * Math.PI * 2,
            waveSpeed: Math.random() * 0.02 + 0.01,
            waveAmplitude: Math.random() * 30 + 20,
            originalY: 0,
            directionChangeTimer: Math.random() * 300 + 200,
            isRedFish: type.img === 'fish_red',
            isCrowned: isRare, // редкая рыба всегда с короной
            isRare: isRare
          });
        }
      });
      fishArr.forEach(fish => { fish.baseSize = fish.size; });
      return fishArr;
    }



    let score = 0;
    let fishArr = [];
    let img = null;
    // Заменяем одиночный food на массив foods
    let foods = [];

    loadImages(assets, (images) => {
      img = images;
      // canvas и ctx уже определены выше
      function drawBackground() {
        // Градиентный фон
        let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#b3e6ff');
        grad.addColorStop(1, '#7fd0f7');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img.sand, 0, canvas.height - 100, canvas.width, 100);
        ctx.drawImage(img.sand_top, 0, canvas.height - 120, canvas.width, 20);
      }

      function drawBottom() {
        const t = Date.now() * 0.001;
        // Сортировка по основанию (y + высота): чем больше, тем ближе к зрителю
        const sorted = [...bottomElements].sort((a, b) => {
          let aBase = a.y, bBase = b.y;
          if (img[a.img]) aBase = a.y + img[a.img].height * a.scale;
          if (img[b.img]) bBase = b.y + img[b.img].height * b.scale;
          return aBase - bBase;
        });
        sorted.forEach(el => {
          let imgObj = img[el.img];
          if (!imgObj) {
            console.error('Asset not found:', el.img);
            return; // если ассет не найден, пропустить элемент
          }
          ctx.save();
          let angle = el.angle || 0;
          let alpha = el.alpha || 1;
          let shear = 0;
          let scale = el.scale;
          let h = imgObj.height * scale;
          let w = imgObj.width * scale;
          // --- Качание только для ассетов из SEAWEED_ASSETS ---
          let isSeaweed = typeof SEAWEED_ASSETS !== 'undefined' && SEAWEED_ASSETS.has(el.img);
          if (isSeaweed) {
            console.log('Качается:', el.img);
            shear = Math.sin(t * 1.2 + el.x * 0.01) * 0.22;
          }
          ctx.globalAlpha = alpha;
          if (isSeaweed) {
            ctx.translate(el.x, el.y + h); // основание
            ctx.transform(1, 0, shear, 1, 0, 0);
            ctx.rotate(angle);
            ctx.drawImage(imgObj, 0, -h, w, h);
          } else {
          ctx.translate(el.x, el.y);
            ctx.rotate(angle);
            ctx.drawImage(imgObj, 0, 0, w, h);
          }
          ctx.restore();
        });
      }

      function drawHUD() {
        ctx.save();
        ctx.font = 'bold ' + Math.floor(canvas.height * 0.07) + 'px Arial';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 6;
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#fff';
        ctx.strokeText(score + ' очков', canvas.width - 30, 20);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffcc22';
        ctx.fillText(score + ' очков', canvas.width - 30, 20);
        ctx.restore();
      }

      function drawFish() {
        fishArr.forEach(fish => {
          ctx.save();
          ctx.translate(fish.x, fish.y);
          if (fish.dir === -1) {
            ctx.scale(-1, 1);
          }
          // Для красной рыбы добавляем легкую анимацию
          if (fish.isRedFish) {
            const finRotation = Math.sin(Date.now() * 0.008 + fish.waveOffset) * 0.15;
            ctx.rotate(finRotation);
          }
          // --- Редкая рыба: рисуем золотой фильтр и свечение ---
          if (fish.isRare) {
            // Золотое свечение
            ctx.save();
            ctx.shadowColor = '#ffe066';
            ctx.shadowBlur = 32;
            ctx.globalAlpha = 0.85;
            ctx.drawImage(fish.img, -fish.img.width * fish.size / 2, -fish.img.height * fish.size / 2, fish.img.width * fish.size, fish.img.height * fish.size);
            ctx.restore();
            // Золотой фильтр
            ctx.globalAlpha = 0.7;
            ctx.globalCompositeOperation = 'lighter';
            ctx.drawImage(fish.img, -fish.img.width * fish.size / 2, -fish.img.height * fish.size / 2, fish.img.width * fish.size, fish.img.height * fish.size);
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
          } else {
          ctx.drawImage(fish.img, -fish.img.width * fish.size / 2, -fish.img.height * fish.size / 2, fish.img.width * fish.size, fish.img.height * fish.size);
          }
          // --- Корона ---
          if (fish.isCrowned) {
            ctx.save();
            ctx.translate(0, -fish.img.height * fish.size / 2 - 12);
            ctx.beginPath();
            ctx.moveTo(-10, 10);
            ctx.lineTo(-6, -2);
            ctx.lineTo(-2, 8);
            ctx.lineTo(2, -2);
            ctx.lineTo(6, 8);
            ctx.lineTo(10, -2);
            ctx.lineTo(14, 10);
            ctx.closePath();
            ctx.fillStyle = fish.isRare ? '#fff6a0' : '#ffd700';
            ctx.strokeStyle = fish.isRare ? '#ffe066' : '#e5b700';
            ctx.lineWidth = 2.5;
            ctx.shadowColor = fish.isRare ? '#fff6a0' : '#fff';
            ctx.shadowBlur = fish.isRare ? 16 : 6;
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
          ctx.restore();
        });
      }

      function drawBubbles() {
        fishArr.forEach(fish => {
          fish.bubbles.forEach(bubble => {
            ctx.save();
            ctx.globalAlpha = bubble.alpha;
            // Случайное смещение центра для мультяшности
            const offsetX = (Math.random() - 0.5) * bubble.size * 2.5;
            const offsetY = (Math.random() - 0.5) * bubble.size * 2.5;
            ctx.beginPath();
            if (bubble.ellipse) {
              ctx.ellipse(bubble.x + offsetX, bubble.y + offsetY, bubble.size * 9, bubble.ellipseY * 9, Math.random() * Math.PI, 0, 2 * Math.PI);
            } else {
              ctx.arc(bubble.x + offsetX, bubble.y + offsetY, bubble.size * 9, 0, 2 * Math.PI);
            }
            // Градиент для пузырька
            const grad = ctx.createRadialGradient(bubble.x + offsetX, bubble.y + offsetY, 0, bubble.x + offsetX, bubble.y + offsetY, bubble.size * 9);
            grad.addColorStop(0, 'rgba(255,255,255,0.95)');
            grad.addColorStop(0.7, 'rgba(180,220,255,0.45)');
            grad.addColorStop(1, 'rgba(120,180,255,0.18)');
            ctx.fillStyle = grad;
            ctx.fill();
            // Мультяшный контур
            ctx.lineWidth = 2.2;
            ctx.strokeStyle = 'rgba(180,220,255,0.85)';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Яркий блик (дуга)
            ctx.beginPath();
            ctx.arc(bubble.x + offsetX - bubble.size * 2.5, bubble.y + offsetY - bubble.size * 2.5, bubble.size * 2.2, Math.PI * 0.8, Math.PI * 1.6);
            ctx.strokeStyle = 'rgba(255,255,255,0.95)';
            ctx.lineWidth = 1.1;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 4;
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Внутренний рефлекс (полукруг)
            ctx.beginPath();
            ctx.arc(bubble.x + offsetX + bubble.size * 2.2, bubble.y + offsetY + bubble.size * 1.2, bubble.size * 1.5, Math.PI * 1.1, Math.PI * 1.9);
            ctx.strokeStyle = 'rgba(255,255,255,0.45)';
            ctx.lineWidth = 0.9;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.restore();
          });
        });
      }

      // Адаптируем drawFood для отрисовки каждой крошки индивидуально
      function drawFood() {
        foods.forEach(crumb => {
          if (!crumb.active) return;
          ctx.save();
          ctx.globalAlpha = crumb.alpha;
          
          // Тень
          ctx.save();
          ctx.globalAlpha = crumb.alpha * 0.25;
          ctx.beginPath();
          ctx.ellipse(crumb.x + 5, crumb.y + crumb.radius * 1.2, crumb.radius * 1.1, crumb.radius * 0.5, 0, 0, 2 * Math.PI);
          ctx.fillStyle = '#bfae5a';
          ctx.filter = 'blur(2px)';
          ctx.fill();
          ctx.restore();
          
          // Градиент
          const grad = ctx.createRadialGradient(
            crumb.x - crumb.radius * 0.5, 
            crumb.y - crumb.radius * 0.5, 
            crumb.radius * 0.2, 
            crumb.x, 
            crumb.y, 
            crumb.radius
          );
          grad.addColorStop(0, '#fffbe0');
          grad.addColorStop(0.4, '#ffe066');
          grad.addColorStop(0.8, '#ffcc22');
          grad.addColorStop(1, '#e6a800');
          
          // Форма крошки (неровная или круглая)
          ctx.beginPath();
          if (crumb.isRound) {
            // Круглая крошка
            ctx.arc(crumb.x, crumb.y, crumb.radius, 0, 2 * Math.PI);
          } else {
            // Неправильная форма крошки с предрассчитанными точками
            ctx.moveTo(
              crumb.x + crumb.points[0].x,
              crumb.y + crumb.points[0].y
            );
            for (let j = 1; j < crumb.points.length; j++) {
              ctx.lineTo(
                crumb.x + crumb.points[j].x,
                crumb.y + crumb.points[j].y
              );
            }
            ctx.closePath();
          }
          
          ctx.fillStyle = grad;
          ctx.shadowColor = '#fffbe0';
          ctx.shadowBlur = 6;
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Мультяшный контур
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = '#e6a800';
          ctx.stroke();
          
          // Блик на крошке
          ctx.beginPath();
          ctx.arc(
            crumb.x - crumb.radius * 0.3, 
            crumb.y - crumb.radius * 0.4, 
            crumb.radius * 0.5, 
            Math.PI * 1.1, 
            Math.PI * 1.9
          );
          ctx.strokeStyle = 'rgba(255,255,255,0.85)';
          ctx.lineWidth = 0.8;
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = 3;
          ctx.stroke();
          ctx.shadowBlur = 0;
          
          ctx.restore();
        });
      }

      function animate() {
        drawBackground();
        drawBottom();
        drawBubbles();
        drawFish();
        drawHUD();
        drawFood();

        // === Mikasa (висящий персонаж) ===
        if (mikasaLoaded) {
          const mikasaWidth = canvas.width * 0.18;
          const mikasaHeight = canvas.height * 0.42;
        const mikasaX = canvas.width / 2 - mikasaWidth / 2;
        const mikasaY = 0;
        ctx.beginPath();
          ctx.moveTo(canvas.width / 2, 0);
          ctx.lineTo(canvas.width / 2, mikasaY + mikasaHeight * 0.16);
        ctx.strokeStyle = "#c9bfa3";
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.drawImage(mikasaImg, mikasaX, mikasaY, mikasaWidth, mikasaHeight);
        }

        // Найти ближайшую крошку к каждой рыбе
        let targetPairs = [];
        if (foods.length > 0) {
          fishArr.forEach((fish, fishIdx) => {
            let minDist = Infinity;
            let closestCrumbIdx = -1;
            foods.forEach((crumb, crumbIdx) => {
              if (crumb.active && crumb.state !== 'eaten') {
                const dx = crumb.x - fish.x;
                const dy = crumb.y - fish.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                  minDist = dist;
                  closestCrumbIdx = crumbIdx;
                }
              }
            });
            if (closestCrumbIdx !== -1 && minDist < 150) { // лимит расстояния для реакции
              targetPairs.push({fishIdx, crumbIdx: closestCrumbIdx, dist: minDist});
            }
          });
          // Сортируем пары по расстоянию и берём лучшие (например, до 3)
          targetPairs.sort((a, b) => a.dist - b.dist);
          targetPairs = targetPairs.slice(0, 3);
        }

        fishArr.forEach((fish, idx) => {
          // Инициализируем originalY при первом запуске
          if (fish.originalY === 0) {
            fish.originalY = fish.y;
          }
          
          const pair = targetPairs.find(p => p.fishIdx === idx);
          if (pair && foods.length > 0) {
            const crumb = foods[pair.crumbIdx];
            if (crumb.active && crumb.state !== 'eaten') {
              const dx = crumb.x - fish.x;
              const dy = crumb.y - fish.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              if (dist > 2) {
                const angle = Math.atan2(dy, dx);
                const step = fish.speed * 1.2;
                const maxVerticalStep = 1.5;
                let nextX = fish.x + Math.cos(angle) * step;
                let nextY = fish.y + Math.sin(angle) * step;
                let verticalDelta = nextY - fish.y;
                if (Math.abs(verticalDelta) > maxVerticalStep) {
                  nextY = fish.y + Math.sign(verticalDelta) * maxVerticalStep;
                }
                fish.x = nextX;
                fish.y = nextY;
                fish.dir = dx > 0 ? 1 : -1;
              }
              if (dist < (crumb.radius + 20)) {
                crumb.state = 'eaten';
                score += 5;
                // --- Механика роста ---
                fish.feedCount = (fish.feedCount || 0) + 1;
                if (fish.feedCount % 3 === 0) {
                  const maxSize = fish.baseSize * 2;
                  fish.size = Math.min(fish.size * 1.1, maxSize);
                }
                // --- Анимация пузырьков при кормлении ---
                const bubbleCount = Math.round(2 + fish.size * 2); // от 2 до 5
                for (let b = 0; b < bubbleCount; b++) {
                  const bubSize = fish.size * (0.18 + Math.random() * 0.12); // меньше, зависит от рыбы
                  const isEllipse = Math.random() < 0.4;
                  fish.bubbles.push({
                    x: fish.x + (Math.random() - 0.5) * 10,
                    y: fish.y - (fish.img.height * fish.size / 2) + (Math.random() * 8 - 4),
                    size: bubSize,
                    alpha: 0.7 + Math.random() * 0.2,
                    speed: 1.2 + Math.random() * 1.2,
                    drift: (Math.random() - 0.5) * 0.5, // дрейф вбок
                    ellipse: isEllipse,
                    ellipseY: isEllipse ? bubSize * (0.7 + Math.random() * 0.3) : bubSize
                  });
                }
              }
            }
          } else {
            // Обычное движение и ограничения по y
          fish.x += fish.speed * fish.dir;
            if (fish.y < 60) fish.y = 60;
            if (fish.y > canvas.height - 120) fish.y = canvas.height - 120;
            // Вертикальное синусоидальное движение только для обычных рыб
            fish.waveOffset += fish.waveSpeed;
            fish.y = fish.originalY + Math.sin(fish.waveOffset) * fish.waveAmplitude;
            // Случайные изменения направления
            fish.directionChangeTimer--;
            if (fish.directionChangeTimer <= 0) {
              if (Math.random() < 0.3) {
                fish.dir *= -1;
              }
              fish.directionChangeTimer = Math.random() * 300 + 200;
            }
            if (fish.x < -100 || fish.x > canvas.width + 100) {
            fish.dir *= -1;
            }
          }
          
          fish.bubbleTimer--;
          if (fish.bubbleTimer <= 0) {
            fish.bubbles.push({
              x: fish.x + (Math.random() - 0.5) * 10,
              y: fish.y - 10,
              size: Math.random() * 0.7 + 0.5,
              alpha: 0.8 + Math.random() * 0.2,
              speed: 1.2 + Math.random() * 1.2
            });
            fish.bubbleTimer = Math.random() * 120 + 80;
          }
          // --- Рост со временем ---
          fish.ageTimer = (fish.ageTimer || 0) + 1;
          if (!fish.isCrowned && fish.ageTimer % (15 * 60) === 0) { // 15 секунд при 60 FPS
            const maxSize = fish.baseSize * 2;
            if (fish.size < maxSize) {
              fish.size = Math.min(fish.size * 1.1, maxSize);
            }
          }
          // --- Корона ---
          if (!fish.isCrowned && fish.size >= fish.baseSize * 2 - 0.01) {
            fish.isCrowned = true;
          }
        });

        fishArr.forEach(fish => {
          fish.bubbles.forEach(bubble => {
            bubble.y -= bubble.speed;
            bubble.x += bubble.drift || 0;
            bubble.alpha -= 0.004; // чуть быстрее исчезают
          });
          fish.bubbles = fish.bubbles.filter(b => b.y > 0 && b.alpha > 0.1);
        });

        // === Анимация корма ===
        foods.forEach((crumb, index) => {
          if (crumb.active) {
            const sandBottomY = canvas.height;
            if (crumb.state === 'falling') {
              crumb.vy += 0.03; // очень медленная гравитация
              crumb.y += crumb.vy;
              crumb.x += crumb.drift;
              
              // Очень слабые колебания, почти незаметные
              crumb.x += Math.sin(Date.now() / 2000 + crumb.randomOffset) * 0.05;
              
              // Сначала падает до точки клика, потом дальше вниз до дна
              if (crumb.y >= crumb.targetY) {
                crumb.state = 'dropping';
              }
            } else if (crumb.state === 'dropping') {
              crumb.vy += 0.03; // очень медленная гравитация
              crumb.y += crumb.vy;
              crumb.x += crumb.drift;
              
              // Очень слабые колебания, почти незаметные
              crumb.x += Math.sin(Date.now() / 2000 + crumb.randomOffset) * 0.05;
              
              if (crumb.y >= sandBottomY - crumb.radius - 8) {
                crumb.y = sandBottomY - crumb.radius - 8;
                crumb.vy = 0;
                crumb.state = 'idle';
              }
            } else if (crumb.state === 'eaten') {
              crumb.alpha -= 0.07;
              crumb.radius *= 0.93;
              if (crumb.alpha <= 0.05 || crumb.radius < 2) {
                crumb.active = false;
              }
            }
          }
        });
        foods = foods.filter(crumb => crumb.active); // Удаляем съеденные

        requestAnimationFrame(animate);
      }

      function regenerateAll() {
        bottomElements = generateBottomElements(img);
        fishArr = generateFish(img);
      }

      regenerateAll();
      animate();

      window.addEventListener('resize', () => {
        resizeCanvas();
        regenerateAll();
      });

      function hasRareFish() {
        return fishArr.some(f => f.isRare);
      }

      canvas.addEventListener('mousedown', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const my = (e.clientY - rect.top) * (canvas.height / rect.height);
        let clickedOnFish = false;
        for (let i = 0; i < fishArr.length; i++) {
          const fish = fishArr[i];
          const w = fish.img.width * fish.size;
          const h = fish.img.height * fish.size;
          const fx = fish.x - w/2;
          const fy = fish.y - h/2;
          if (mx >= fx && mx <= fx + w && my >= fy && my <= fy + h) {
            score += 10;
            const type = fishTypes.find(t => img[t.img] === fish.img);
            let newFish;
            // --- Редкая рыба: шанс только если в аквариуме нет редкой ---
            let isRare = false;
            let fishImg = fish.img;
            if (!hasRareFish() && Math.random() < 1/20) {
              isRare = true;
              fishImg = img['fish_orange'];
            } else if (type) {
              fishImg = fish.img;
            } else {
              const t = fishTypes[Math.floor(Math.random() * fishTypes.length)];
              fishImg = img[t.img];
            }
            const newY = Math.random() * (canvas.height - 180) + 60;
              newFish = {
              img: fishImg,
              x: Math.random() * (canvas.width - 180) + 90,
              y: newY,
              speed: Math.random() * 1.5 + 0.5 + (isRare ? 0.5 : 0),
                dir: Math.random() > 0.5 ? 1 : -1,
              size: (Math.random() * 0.5 + 0.7) * (isRare ? 1.18 : 1),
              baseSize: 0,
              feedCount: 0,
              ageTimer: 0,
                bubbleTimer: Math.random() * 80 + 40,
              bubbles: [],
              waveOffset: Math.random() * Math.PI * 2,
              waveSpeed: Math.random() * 0.02 + 0.01,
              waveAmplitude: Math.random() * 30 + 20,
              originalY: newY,
              directionChangeTimer: Math.random() * 300 + 200,
              isRedFish: type && type.img === 'fish_red',
              isCrowned: isRare,
              isRare: isRare
            };
            newFish.baseSize = newFish.size;
            fishArr.splice(i, 1, newFish);
            clickedOnFish = true;
            break;
          }
        }
        if (!clickedOnFish) {
          const crumbCount = 3 + Math.floor(Math.random() * 2); // 3-4 крошки
          for (let i = 0; i < crumbCount; i++) {
            let startY = my - 50;
            if (startY < 0) startY = 0;
            const crumb = {
              x: mx + (Math.random() - 0.5) * 20, // больший разброс
              y: startY + (Math.random() - 0.5) * 10, // небольшой разброс по Y
              targetY: my + (Math.random() - 0.5) * 30, // вариация цели
              vy: 0.2 + Math.random() * 0.3 + (Math.random() - 0.5) * 0.1, // вариация скорости
              drift: (Math.random() - 0.5) * 0.3, // индивидуальный дрейф
              radius: 6 + Math.random() * 3, // индивидуальный размер
              alpha: 1,
              state: 'falling',
              active: true,
              randomOffset: Math.random() * Math.PI * 2, // для колебаний
              isRound: Math.random() > 0.5,
              points: Array(8).fill().map((_, j) => {
                const angle = j * Math.PI / 4;
                const radiusVar = 6 + Math.random() * 3; // базовый радиус для точек
                const pointRadius = radiusVar * (0.8 + Math.random() * 0.4);
                return {
                  x: Math.cos(angle) * pointRadius,
                  y: Math.sin(angle) * pointRadius
                };
              })
            };
            foods.push(crumb);
          }
        }
      });

      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = (touch.clientX - rect.left) * (canvas.width / rect.width);
        const my = (touch.clientY - rect.top) * (canvas.height / rect.height);
        let clickedOnFish = false;
        for (let i = 0; i < fishArr.length; i++) {
          const fish = fishArr[i];
          const w = fish.img.width * fish.size;
          const h = fish.img.height * fish.size;
          const fx = fish.x - w/2;
          const fy = fish.y - h/2;
          if (mx >= fx && mx <= fx + w && my >= fy && my <= fy + h) {
            score += 10;
            const type = fishTypes.find(t => img[t.img] === fish.img);
            let newFish;
            // --- Редкая рыба: шанс только если в аквариуме нет редкой ---
            let isRare = false;
            let fishImg = fish.img;
            if (!hasRareFish() && Math.random() < 1/20) {
              isRare = true;
              fishImg = img['fish_orange'];
            } else if (type) {
              fishImg = fish.img;
            } else {
              const t = fishTypes[Math.floor(Math.random() * fishTypes.length)];
              fishImg = img[t.img];
            }
            const newY = Math.random() * (canvas.height - 180) + 60;
              newFish = {
              img: fishImg,
              x: Math.random() * (canvas.width - 180) + 90,
              y: newY,
              speed: Math.random() * 1.5 + 0.5 + (isRare ? 0.5 : 0),
                dir: Math.random() > 0.5 ? 1 : -1,
              size: (Math.random() * 0.5 + 0.7) * (isRare ? 1.18 : 1),
              baseSize: 0,
              feedCount: 0,
              ageTimer: 0,
                bubbleTimer: Math.random() * 80 + 40,
              bubbles: [],
              waveOffset: Math.random() * Math.PI * 2,
              waveSpeed: Math.random() * 0.02 + 0.01,
              waveAmplitude: Math.random() * 30 + 20,
              originalY: newY,
              directionChangeTimer: Math.random() * 300 + 200,
              isRedFish: type && type.img === 'fish_red',
              isCrowned: isRare,
              isRare: isRare
            };
            newFish.baseSize = newFish.size;
            fishArr.splice(i, 1, newFish);
            clickedOnFish = true;
            break;
          }
        }
        if (!clickedOnFish) {
          const crumbCount = 3 + Math.floor(Math.random() * 2); // 3-4 крошки
          for (let i = 0; i < crumbCount; i++) {
            let startY = my - 50;
            if (startY < 0) startY = 0;
            const crumb = {
              x: mx + (Math.random() - 0.5) * 20, // больший разброс
              y: startY + (Math.random() - 0.5) * 10, // небольшой разброс по Y
              targetY: my + (Math.random() - 0.5) * 30, // вариация цели
              vy: 0.2 + Math.random() * 0.3 + (Math.random() - 0.5) * 0.1, // вариация скорости
              drift: (Math.random() - 0.5) * 0.3, // индивидуальный дрейф
              radius: 6 + Math.random() * 3, // индивидуальный размер
              alpha: 1,
              state: 'falling',
              active: true,
              randomOffset: Math.random() * Math.PI * 2, // для колебаний
              isRound: Math.random() > 0.5,
              points: Array(8).fill().map((_, j) => {
                const angle = j * Math.PI / 4;
                const radiusVar = 6 + Math.random() * 3; // базовый радиус для точек
                const pointRadius = radiusVar * (0.8 + Math.random() * 0.4);
                return {
                  x: Math.cos(angle) * pointRadius,
                  y: Math.sin(angle) * pointRadius
                };
              })
            };
            foods.push(crumb);
          }
        }
      }, {passive: false});
    });
  </script>
</body>
</html> 